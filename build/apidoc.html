<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

    >sylvester (v0.0.21)</a>
</h1>
<h4>node.js implementation of James Coglan's "Sylvester" matrix math library.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester">module sylvester</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line">
            function <span class="apidocSignatureSpan">sylvester.</span>Line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment">
            function <span class="apidocSignatureSpan">sylvester.</span>Line.Segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix">
            function <span class="apidocSignatureSpan">sylvester.</span>Matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane">
            function <span class="apidocSignatureSpan">sylvester.</span>Plane
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector">
            function <span class="apidocSignatureSpan">sylvester.</span>Vector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist">
            function <span class="apidocSignatureSpan">sylvester.</span>linkedlist
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon">
            function <span class="apidocSignatureSpan">sylvester.</span>polygon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>Line.Segment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>Line.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>Matrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>Plane.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>Sylvester</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>Vector.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>linkedlist.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.</span>polygon.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Line">module sylvester.Line</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Line">
            function <span class="apidocSignatureSpan">sylvester.</span>Line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment">
            function <span class="apidocSignatureSpan">sylvester.Line.</span>Segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.create">
            function <span class="apidocSignatureSpan">sylvester.Line.</span>create
            <span class="apidocSignatureSpan">(anchor, direction)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Line.</span>X</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Line.</span>Y</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Line.</span>Z</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Line.Segment">module sylvester.Line.Segment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.Segment">
            function <span class="apidocSignatureSpan">sylvester.Line.</span>Segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.create">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.</span>create
            <span class="apidocSignatureSpan">(v1, v2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Line.Segment.prototype">module sylvester.Line.Segment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.bisectingPlane">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>bisectingPlane
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.contains">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>contains
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.distanceFrom">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>distanceFrom
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.dup">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>dup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.eql">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>eql
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.intersectionWith">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>intersectionWith
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.intersects">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>intersects
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.isParallelTo">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>isParallelTo
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.length">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.midpoint">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>midpoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.pointClosestTo">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>pointClosestTo
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.setPoints">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>setPoints
            <span class="apidocSignatureSpan">(startPoint, endPoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.toVector">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>toVector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.Segment.prototype.translate">
            function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>translate
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Line.prototype">module sylvester.Line.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.contains">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>contains
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.distanceFrom">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>distanceFrom
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.dup">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>dup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.eql">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>eql
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.intersectionWith">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>intersectionWith
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.intersects">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>intersects
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.isParallelTo">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>isParallelTo
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.liesIn">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>liesIn
            <span class="apidocSignatureSpan">(plane)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.pointClosestTo">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>pointClosestTo
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.positionOf">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>positionOf
            <span class="apidocSignatureSpan">(point)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.reflectionIn">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>reflectionIn
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.reverse">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.rotate">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>rotate
            <span class="apidocSignatureSpan">(t, line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.setVectors">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>setVectors
            <span class="apidocSignatureSpan">(anchor, direction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Line.prototype.translate">
            function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>translate
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Matrix">module sylvester.Matrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Matrix">
            function <span class="apidocSignatureSpan">sylvester.</span>Matrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Diagonal">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Diagonal
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Fill">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Fill
            <span class="apidocSignatureSpan">(n, m, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.I">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>I
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.One">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>One
            <span class="apidocSignatureSpan">(n, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Ones">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Ones
            <span class="apidocSignatureSpan">(n, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Random">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Random
            <span class="apidocSignatureSpan">(n, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Rotation">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Rotation
            <span class="apidocSignatureSpan">(theta, a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.RotationX">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>RotationX
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.RotationY">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>RotationY
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.RotationZ">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>RotationZ
            <span class="apidocSignatureSpan">(t)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Zero">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Zero
            <span class="apidocSignatureSpan">(n, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.Zeros">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Zeros
            <span class="apidocSignatureSpan">(n, m)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.create">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>create
            <span class="apidocSignatureSpan">(aElements, ignoreLapack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.loadFile">
            function <span class="apidocSignatureSpan">sylvester.Matrix.</span>loadFile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Matrix.prototype">module sylvester.Matrix.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.add">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>add
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.approxEql">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>approxEql
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.augment">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>augment
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.backSubstitute">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>backSubstitute
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.canMultiplyFromLeft">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>canMultiplyFromLeft
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.col">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>col
            <span class="apidocSignatureSpan">(j)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.cols">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>cols
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.column">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>column
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.det">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>det
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.determinant">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>determinant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.diagonal">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>diagonal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.dimensions">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>dimensions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.div">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>div
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.dup">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>dup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.e">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>e
            <span class="apidocSignatureSpan">(i, j)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.elementMultiply">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>elementMultiply
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.eql">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>eql
            <span class="apidocSignatureSpan">(matrix, precision)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.forwardSubstitute">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>forwardSubstitute
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.indexOf">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.inspect">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.inv">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>inv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.inverse">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>inverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.isSameSizeAs">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>isSameSizeAs
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.isSingular">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>isSingular
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.isSquare">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>isSquare
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.log">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.lu">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>lu
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.luJs">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>luJs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.luPack">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>luPack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.map">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>map
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.max">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.maxColumnIndexes">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>maxColumnIndexes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.maxColumns">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>maxColumns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.mean">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>mean
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.minColumnIndexes">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>minColumnIndexes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.minColumns">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>minColumns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.minor">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>minor
            <span class="apidocSignatureSpan">(a, b, c, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.mulOp">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>mulOp
            <span class="apidocSignatureSpan">(matrix, op)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.multiply">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>multiply
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.partialPivot">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>partialPivot
            <span class="apidocSignatureSpan">(k, j, P, A, L)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.pcaProject">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>pcaProject
            <span class="apidocSignatureSpan">(k, U)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.pcaRecover">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>pcaRecover
            <span class="apidocSignatureSpan">(U)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.qr">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>qr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.qrJs">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>qrJs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.qrPack">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>qrPack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.rank">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>rank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.rk">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>rk
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.round">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.row">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>row
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.rows">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>rows
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.setElements">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>setElements
            <span class="apidocSignatureSpan">(els)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.slice">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>slice
            <span class="apidocSignatureSpan">(startRow, endRow, startCol, endCol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.snapTo">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>snapTo
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.solve">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>solve
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.subtract">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>subtract
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.sum">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>sum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.svd">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>svd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.svdJs">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>svdJs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.svdPack">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>svdPack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.toArray">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.toRightTriangular">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>toRightTriangular
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.toUpperTriangular">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>toUpperTriangular
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.tr">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>tr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.trace">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>trace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.transpose">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>transpose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.triu">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>triu
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.unroll">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>unroll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Matrix.prototype.x">
            function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>x
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Plane">module sylvester.Plane</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.Plane">
            function <span class="apidocSignatureSpan">sylvester.</span>Plane
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.create">
            function <span class="apidocSignatureSpan">sylvester.Plane.</span>create
            <span class="apidocSignatureSpan">(anchor, v1, v2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.fromPoints">
            function <span class="apidocSignatureSpan">sylvester.Plane.</span>fromPoints
            <span class="apidocSignatureSpan">(points)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Plane.</span>XY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Plane.</span>XZ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Plane.</span>YX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Plane.</span>YZ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Plane.</span>ZX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Plane.</span>ZY</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Plane.prototype">module sylvester.Plane.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.contains">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>contains
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.distanceFrom">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>distanceFrom
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.dup">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>dup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.eql">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>eql
            <span class="apidocSignatureSpan">(plane)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.intersectionWith">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>intersectionWith
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.intersects">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>intersects
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.isParallelTo">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>isParallelTo
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.isPerpendicularTo">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>isPerpendicularTo
            <span class="apidocSignatureSpan">(plane)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.pointClosestTo">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>pointClosestTo
            <span class="apidocSignatureSpan">(point)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.reflectionIn">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>reflectionIn
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.rotate">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>rotate
            <span class="apidocSignatureSpan">(t, line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.setVectors">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>setVectors
            <span class="apidocSignatureSpan">(anchor, v1, v2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Plane.prototype.translate">
            function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>translate
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Vector">module sylvester.Vector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.Vector">
            function <span class="apidocSignatureSpan">sylvester.</span>Vector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.Fill">
            function <span class="apidocSignatureSpan">sylvester.Vector.</span>Fill
            <span class="apidocSignatureSpan">(n, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.One">
            function <span class="apidocSignatureSpan">sylvester.Vector.</span>One
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.Random">
            function <span class="apidocSignatureSpan">sylvester.Vector.</span>Random
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.Zero">
            function <span class="apidocSignatureSpan">sylvester.Vector.</span>Zero
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.create">
            function <span class="apidocSignatureSpan">sylvester.Vector.</span>create
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.log">
            function <span class="apidocSignatureSpan">sylvester.Vector.</span>log
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Vector.</span>i</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Vector.</span>j</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.Vector.</span>k</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.Vector.prototype">module sylvester.Vector.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.add">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>add
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.angleFrom">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>angleFrom
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.augment">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>augment
            <span class="apidocSignatureSpan">(elements)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.chomp">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>chomp
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.cols">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>cols
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.cross">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>cross
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.dimensions">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>dimensions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.distanceFrom">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>distanceFrom
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.dot">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>dot
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.dup">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>dup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.e">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>e
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.each">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>each
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.elementDivide">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>elementDivide
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.elementMultiply">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>elementMultiply
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.eql">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>eql
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.indexOf">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.inspect">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.isAntiparallelTo">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>isAntiparallelTo
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.isParallelTo">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>isParallelTo
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.isPerpendicularTo">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>isPerpendicularTo
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.liesIn">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>liesIn
            <span class="apidocSignatureSpan">(plane)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.liesOn">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>liesOn
            <span class="apidocSignatureSpan">(line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.log">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.map">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>map
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.max">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.maxIndex">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>maxIndex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.modulus">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>modulus
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.multiply">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>multiply
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.norm">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>norm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.product">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>product
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.reflectionIn">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>reflectionIn
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.rotate">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>rotate
            <span class="apidocSignatureSpan">(t, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.round">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.rows">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>rows
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.setElements">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>setElements
            <span class="apidocSignatureSpan">(els)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.snapTo">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>snapTo
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.subtract">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>subtract
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.sum">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>sum
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.to3D">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>to3D
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.toDiagonalMatrix">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>toDiagonalMatrix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.toUnitVector">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>toUnitVector
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.top">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>top
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.transpose">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>transpose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.Vector.prototype.x">
            function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>x
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.linkedlist">module sylvester.linkedlist</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.linkedlist">
            function <span class="apidocSignatureSpan">sylvester.</span>linkedlist
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.Circular">
            function <span class="apidocSignatureSpan">sylvester.linkedlist.</span>Circular
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.Node">
            function <span class="apidocSignatureSpan">sylvester.linkedlist.</span>Node
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.linkedlist.prototype">module sylvester.linkedlist.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.prototype.at">
            function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>at
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.prototype.each">
            function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>each
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.prototype.randomNode">
            function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>randomNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.linkedlist.prototype.toArray">
            function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>first</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>last</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.polygon">module sylvester.polygon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.polygon">
            function <span class="apidocSignatureSpan">sylvester.</span>polygon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.create">
            function <span class="apidocSignatureSpan">sylvester.polygon.</span>create
            <span class="apidocSignatureSpan">(points, plane)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sylvester.polygon.prototype">module sylvester.polygon.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.area">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>area
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.centroid">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>centroid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.clearCache">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.contains">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>contains
            <span class="apidocSignatureSpan">(point)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.containsByWindingNumber">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>containsByWindingNumber
            <span class="apidocSignatureSpan">(point)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.copyVertices">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>copyVertices
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.dup">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>dup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.hasEdgeContaining">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>hasEdgeContaining
            <span class="apidocSignatureSpan">(point)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.inspect">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.isTriangle">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>isTriangle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.nodeFor">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>nodeFor
            <span class="apidocSignatureSpan">(vertex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.populateVertexTypeLists">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>populateVertexTypeLists
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.projectionOn">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>projectionOn
            <span class="apidocSignatureSpan">(plane)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.removeVertex">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>removeVertex
            <span class="apidocSignatureSpan">(vertex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.rotate">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>rotate
            <span class="apidocSignatureSpan">(t, line)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.scale">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>scale
            <span class="apidocSignatureSpan">(k, point)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.setCache">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>setCache
            <span class="apidocSignatureSpan">(key, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.setVertices">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>setVertices
            <span class="apidocSignatureSpan">(points, plane)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.toTriangles">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>toTriangles
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.translate">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>translate
            <span class="apidocSignatureSpan">(vector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.trianglesForSurfaceIntegral">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>trianglesForSurfaceIntegral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.triangulateByEarClipping">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>triangulateByEarClipping
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.updateTrianglePlanes">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>updateTrianglePlanes
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sylvester.polygon.prototype.v">
            function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>v
            <span class="apidocSignatureSpan">(i)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester" id="apidoc.module.sylvester">module sylvester</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Line" id="apidoc.element.sylvester.Line">
        function <span class="apidocSignatureSpan">sylvester.</span>Line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Line() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment" id="apidoc.element.sylvester.Line.Segment">
        function <span class="apidocSignatureSpan">sylvester.</span>Line.Segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Line.Segment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix" id="apidoc.element.sylvester.Matrix">
        function <span class="apidocSignatureSpan">sylvester.</span>Matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matrix() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane" id="apidoc.element.sylvester.Plane">
        function <span class="apidocSignatureSpan">sylvester.</span>Plane
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Plane() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector" id="apidoc.element.sylvester.Vector">
        function <span class="apidocSignatureSpan">sylvester.</span>Vector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vector() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.linkedlist" id="apidoc.element.sylvester.linkedlist">
        function <span class="apidocSignatureSpan">sylvester.</span>linkedlist
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon" id="apidoc.element.sylvester.polygon">
        function <span class="apidocSignatureSpan">sylvester.</span>polygon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Polygon() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Line" id="apidoc.module.sylvester.Line">module sylvester.Line</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Line.Line" id="apidoc.element.sylvester.Line.Line">
        function <span class="apidocSignatureSpan">sylvester.</span>Line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Line() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment" id="apidoc.element.sylvester.Line.Segment">
        function <span class="apidocSignatureSpan">sylvester.Line.</span>Segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Segment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.create" id="apidoc.element.sylvester.Line.create">
        function <span class="apidocSignatureSpan">sylvester.Line.</span>create
        <span class="apidocSignatureSpan">(anchor, direction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (anchor, direction) {
  var L = new Line();
  return L.setVectors(anchor, direction);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sylvester = require(&#x27;../lib/node-sylvester&#x27;),
Line = sylvester.Line,
LineSegment = sylvester.Line.Segment,
Vector = sylvester.Vector;

describe(&#x27;line segment&#x27;, function() {
    it(&#x27;should create&#x27;, function() {
	var lineSegment = Line.Segment.<span class="apidocCodeKeywordSpan">create</span>([1, 2], [5, 6]);
	expect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));
    })
});
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Line.Segment" id="apidoc.module.sylvester.Line.Segment">module sylvester.Line.Segment</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.Segment" id="apidoc.element.sylvester.Line.Segment.Segment">
        function <span class="apidocSignatureSpan">sylvester.Line.</span>Segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Segment = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.create" id="apidoc.element.sylvester.Line.Segment.create">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.</span>create
        <span class="apidocSignatureSpan">(v1, v2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (v1, v2) {
  var S = new Line.Segment();
  return S.setPoints(v1, v2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sylvester = require(&#x27;../lib/node-sylvester&#x27;),
Line = sylvester.Line,
LineSegment = sylvester.Line.Segment,
Vector = sylvester.Vector;

describe(&#x27;line segment&#x27;, function() {
    it(&#x27;should create&#x27;, function() {
	var lineSegment = Line.Segment.<span class="apidocCodeKeywordSpan">create</span>([1, 2], [5, 6]);
	expect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));
    })
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Line.Segment.prototype" id="apidoc.module.sylvester.Line.Segment.prototype">module sylvester.Line.Segment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.bisectingPlane" id="apidoc.element.sylvester.Line.Segment.prototype.bisectingPlane">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>bisectingPlane
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bisectingPlane = function () {
  return Plane.create(this.midpoint(), this.toVector());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.contains" id="apidoc.element.sylvester.Line.Segment.prototype.contains">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>contains
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (obj) {
  if (obj.start &#x26;&#x26; obj.end) { return this.contains(obj.start) &#x26;&#x26; this.contains(obj.end); }
  var P = (obj.elements || obj).slice();
  if (P.length == 2) { P.push(0); }
  if (this.start.eql(P)) { return true; }
  var S = this.start.elements;
  var V = Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);
  var vect = this.toVector();
  return V.isAntiparallelTo(vect) &#x26;&#x26; V.modulus() &#x3c;= vect.modulus();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
contains: function(point) {
  return this.containsByWindingNumber(point);
},

// Returns true iff the given point is strictly inside the polygon using the winding number method
containsByWindingNumber: function(point) {
  var P = point.elements || point;
  if (!this.plane.<span class="apidocCodeKeywordSpan">contains</span>(P)) { return false; }
  if (this.hasEdgeContaining(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.distanceFrom" id="apidoc.element.sylvester.Line.Segment.prototype.distanceFrom">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>distanceFrom
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distanceFrom = function (obj) {
  var P = this.pointClosestTo(obj);
  return (P === null) ? null : P.distanceFrom(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.dup" id="apidoc.element.sylvester.Line.Segment.prototype.dup">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>dup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dup = function () {
  return Line.Segment.create(this.start, this.end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
  var poly = this.<span class="apidocCodeKeywordSpan">dup</span>(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.eql" id="apidoc.element.sylvester.Line.Segment.prototype.eql">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>eql
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eql = function (segment) {
  return (this.start.eql(segment.start) &#x26;&#x26; this.end.eql(segment.end)) ||
      (this.start.eql(segment.end) &#x26;&#x26; this.end.eql(segment.start));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var svd = A.svd();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).pcaProject(1).<span class="apidocCodeKeywordSpan">eql</span>($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.pcaRecover(pca.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.intersectionWith" id="apidoc.element.sylvester.Line.Segment.prototype.intersectionWith">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>intersectionWith
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionWith = function (obj) {
  if (!this.line.intersects(obj)) { return null; }
  var P = this.line.intersectionWith(obj);
  return (this.contains(P) ? P : null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.intersects" id="apidoc.element.sylvester.Line.Segment.prototype.intersects">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>intersects
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersects = function (obj) {
  return (this.intersectionWith(obj) !== null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.isParallelTo" id="apidoc.element.sylvester.Line.Segment.prototype.isParallelTo">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>isParallelTo
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isParallelTo = function (obj) {
  return this.line.isParallelTo(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.cross(B).<span class="apidocCodeKeywordSpan">isParallelTo</span>(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
},

// Returns true if the given point lies on an edge of the polygon
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.length" id="apidoc.element.sylvester.Line.Segment.prototype.length">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">length = function () {
  var A = this.start.elements, B = this.end.elements;
  var C1 = B[0] - A[0], C2 = B[1] - A[1], C3 = B[2] - A[2];
  return Math.sqrt(C1*C1 + C2*C2 + C3*C3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.midpoint" id="apidoc.element.sylvester.Line.Segment.prototype.midpoint">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>midpoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">midpoint = function () {
  var A = this.start.elements, B = this.end.elements;
  return Vector.create([(B[0] + A[0])/2, (B[1] + A[1])/2, (B[2] + A[2])/2]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.pointClosestTo" id="apidoc.element.sylvester.Line.Segment.prototype.pointClosestTo">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>pointClosestTo
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pointClosestTo = function (obj) {
  if (obj.normal) {
    // obj is a plane
    var V = this.line.intersectionWith(obj);
    if (V === null) { return null; }
    return this.pointClosestTo(V);
  } else {
    // obj is a line (segment) or point
    var P = this.line.pointClosestTo(obj);
    if (P === null) { return null; }
    if (this.contains(P)) { return P; }
    return (this.line.positionOf(P) &#x3c; 0 ? this.start : this.end).dup();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return V.x(1/M);
  }
},

// Returns the polygon&#x27;s projection on the given plane as another polygon
projectionOn: function(plane) {
  var points = [];
  this.vertices.each(function(node) { points.push(plane.<span class="apidocCodeKeywordSpan">pointClosestTo</span>(node.data)); });
  return Polygon.create(points);
},

// Removes the given vertex from the polygon as long as it&#x27;s not triangular.
removeVertex: function(vertex) {
  if (this.isTriangle()) { return; }
  var node = this.nodeFor(vertex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.setPoints" id="apidoc.element.sylvester.Line.Segment.prototype.setPoints">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>setPoints
        <span class="apidocSignatureSpan">(startPoint, endPoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setPoints = function (startPoint, endPoint) {
  startPoint = Vector.create(startPoint).to3D();
  endPoint = Vector.create(endPoint).to3D();
  if (startPoint === null || endPoint === null) { return null; }
  this.line = Line.create(startPoint, endPoint.subtract(startPoint));
  this.start = startPoint;
  this.end = endPoint;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.toVector" id="apidoc.element.sylvester.Line.Segment.prototype.toVector">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>toVector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toVector = function () {
  var A = this.start.elements, B = this.end.elements;
  return Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.Segment.prototype.translate" id="apidoc.element.sylvester.Line.Segment.prototype.translate">
        function <span class="apidocSignatureSpan">sylvester.Line.Segment.prototype.</span>translate
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translate = function (vector) {
  var V = vector.elements || vector;
  var S = this.start.elements, E = this.end.elements;
  return Line.Segment.create(
    [S[0] + V[0], S[1] + V[1], S[2] + (V[2] || 0)],
    [E[0] + V[0], E[1] + V[1], E[2] + (V[2] || 0)]
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.<span class="apidocCodeKeywordSpan">translate</span>(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Line.prototype" id="apidoc.module.sylvester.Line.prototype">module sylvester.Line.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.contains" id="apidoc.element.sylvester.Line.prototype.contains">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>contains
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (obj) {
  if (obj.start &#x26;&#x26; obj.end) { return this.contains(obj.start) &#x26;&#x26; this.contains(obj.end); }
  var dist = this.distanceFrom(obj);
  return (dist !== null &#x26;&#x26; dist &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
contains: function(point) {
  return this.containsByWindingNumber(point);
},

// Returns true iff the given point is strictly inside the polygon using the winding number method
containsByWindingNumber: function(point) {
  var P = point.elements || point;
  if (!this.plane.<span class="apidocCodeKeywordSpan">contains</span>(P)) { return false; }
  if (this.hasEdgeContaining(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.distanceFrom" id="apidoc.element.sylvester.Line.prototype.distanceFrom">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>distanceFrom
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distanceFrom = function (obj) {
  if (obj.normal || (obj.start &#x26;&#x26; obj.end)) { return obj.distanceFrom(this); }
  if (obj.direction) {
    // obj is a line
    if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }
    var N = this.direction.cross(obj.direction).toUnitVector().elements;
    var A = this.anchor.elements, B = obj.anchor.elements;
    return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
  } else {
    // obj is a point
    var P = obj.elements || obj;
    var A = this.anchor.elements, D = this.direction.elements;
    var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];
    var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);
    if (modPA === 0) return 0;
    // Assumes direction vector is normalized
    var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;
    var sin2 = 1 - cosTheta*cosTheta;
    return Math.abs(modPA * Math.sqrt(sin2 &#x3c; 0 ? 0 : sin2));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.dup" id="apidoc.element.sylvester.Line.prototype.dup">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>dup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dup = function () {
  return Line.create(this.anchor, this.direction);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
  var poly = this.<span class="apidocCodeKeywordSpan">dup</span>(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.eql" id="apidoc.element.sylvester.Line.prototype.eql">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>eql
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eql = function (line) {
  return (this.isParallelTo(line) &#x26;&#x26; this.contains(line.anchor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var svd = A.svd();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).pcaProject(1).<span class="apidocCodeKeywordSpan">eql</span>($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.pcaRecover(pca.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.intersectionWith" id="apidoc.element.sylvester.Line.prototype.intersectionWith">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>intersectionWith
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionWith = function (obj) {
  if (obj.normal || (obj.start &#x26;&#x26; obj.end)) { return obj.intersectionWith(this); }
  if (!this.intersects(obj)) { return null; }
  var P = this.anchor.elements, X = this.direction.elements,
      Q = obj.anchor.elements, Y = obj.direction.elements;
  var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];
  var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];
  var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;
  var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;
  var XdotX = X1*X1 + X2*X2 + X3*X3;
  var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;
  var XdotY = X1*Y1 + X2*Y2 + X3*Y3;
  var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);
  return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.intersects" id="apidoc.element.sylvester.Line.prototype.intersects">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>intersects
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersects = function (obj) {
  if (obj.normal) { return obj.intersects(this); }
  return (!this.isParallelTo(obj) &#x26;&#x26; this.distanceFrom(obj) &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.isParallelTo" id="apidoc.element.sylvester.Line.prototype.isParallelTo">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>isParallelTo
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isParallelTo = function (obj) {
  if (obj.normal || (obj.start &#x26;&#x26; obj.end)) { return obj.isParallelTo(this); }
  var theta = this.direction.angleFrom(obj.direction);
  return (Math.abs(theta) &#x3c;= Sylvester.precision || Math.abs(theta - Math.PI) &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.cross(B).<span class="apidocCodeKeywordSpan">isParallelTo</span>(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
},

// Returns true if the given point lies on an edge of the polygon
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.liesIn" id="apidoc.element.sylvester.Line.prototype.liesIn">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>liesIn
        <span class="apidocSignatureSpan">(plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">liesIn = function (plane) {
  return plane.contains(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.pointClosestTo" id="apidoc.element.sylvester.Line.prototype.pointClosestTo">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>pointClosestTo
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pointClosestTo = function (obj) {
  if (obj.start &#x26;&#x26; obj.end) {
    // obj is a line segment
    var P = obj.pointClosestTo(this);
    return (P === null) ? null : this.pointClosestTo(P);
  } else if (obj.direction) {
    // obj is a line
    if (this.intersects(obj)) { return this.intersectionWith(obj); }
    if (this.isParallelTo(obj)) { return null; }
    var D = this.direction.elements, E = obj.direction.elements;
    var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];
    // Create plane containing obj and the shared normal and intersect this with it
    // Thank you: http://www.cgafaq.info/wiki/Line-line_distance
    var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);
    var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];
    var P = Plane.create(obj.anchor, N);
    return P.intersectionWith(this);
  } else {
    // obj is a point
    var P = obj.elements || obj;
    if (this.contains(P)) { return Vector.create(P); }
    var A = this.anchor.elements, D = this.direction.elements;
    var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];
    var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),
        z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);
    var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);
    var k = this.distanceFrom(P) / V.modulus();
    return Vector.create([
      P[0] + V.elements[0] * k,
      P[1] + V.elements[1] * k,
      (P[2] || 0) + V.elements[2] * k
    ]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return V.x(1/M);
  }
},

// Returns the polygon&#x27;s projection on the given plane as another polygon
projectionOn: function(plane) {
  var points = [];
  this.vertices.each(function(node) { points.push(plane.<span class="apidocCodeKeywordSpan">pointClosestTo</span>(node.data)); });
  return Polygon.create(points);
},

// Removes the given vertex from the polygon as long as it&#x27;s not triangular.
removeVertex: function(vertex) {
  if (this.isTriangle()) { return; }
  var node = this.nodeFor(vertex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.positionOf" id="apidoc.element.sylvester.Line.prototype.positionOf">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>positionOf
        <span class="apidocSignatureSpan">(point)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">positionOf = function (point) {
  if (!this.contains(point)) { return null; }
  var P = point.elements || point;
  var A = this.anchor.elements, D = this.direction.elements;
  return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.reflectionIn" id="apidoc.element.sylvester.Line.prototype.reflectionIn">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>reflectionIn
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reflectionIn = function (obj) {
  if (obj.normal) {
    // obj is a plane
    var A = this.anchor.elements, D = this.direction.elements;
    var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];
    var newA = this.anchor.reflectionIn(obj).elements;
    // Add the line&#x27;s direction vector to its anchor, then mirror that in the plane
    var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;
    var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;
    var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];
    return Line.create(newA, newD);
  } else if (obj.direction) {
    // obj is a line - reflection obtained by rotating PI radians about obj
    return this.rotate(Math.PI, obj);
  } else {
    // obj is a point - just reflect the line&#x27;s anchor in it
    var P = obj.elements || obj;
    return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.reverse" id="apidoc.element.sylvester.Line.prototype.reverse">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  return Line.create(this.anchor, this.direction.x(-1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.rotate" id="apidoc.element.sylvester.Line.prototype.rotate">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>rotate
        <span class="apidocSignatureSpan">(t, line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotate = function (t, line) {
  // If we&#x27;re working in 2D
  if (typeof(line.direction) == &#x27;undefined&#x27;) { line = Line.create(line.to3D(), Vector.k); }
  var R = Matrix.Rotation(t, line.direction).elements;
  var C = line.pointClosestTo(this.anchor).elements;
  var A = this.anchor.elements, D = this.direction.elements;
  var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
  var x = A1 - C1, y = A2 - C2, z = A3 - C3;
  return Line.create([
    C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
    C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
    C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
  ], [
    R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],
    R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],
    R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
  this.vertices.each(function(node) {
    node.data.setElements(node.data.<span class="apidocCodeKeywordSpan">rotate</span>(R, line).elements);
  });
  this.plane = this.plane.rotate(R, line);
  this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });
  return this;
},

// Scales the polygon relative to the given point and returns the polygon.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.setVectors" id="apidoc.element.sylvester.Line.prototype.setVectors">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>setVectors
        <span class="apidocSignatureSpan">(anchor, direction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setVectors = function (anchor, direction) {
  // Need to do this so that line&#x27;s properties are not
  // references to the arguments passed in
  anchor = Vector.create(anchor);
  direction = Vector.create(direction);
  if (anchor.elements.length == 2) {anchor.elements.push(0); }
  if (direction.elements.length == 2) { direction.elements.push(0); }
  if (anchor.elements.length &#x3e; 3 || direction.elements.length &#x3e; 3) { return null; }
  var mod = direction.modulus();
  if (mod === 0) { return null; }
  this.anchor = anchor;
  this.direction = Vector.create([
    direction.elements[0] / mod,
    direction.elements[1] / mod,
    direction.elements[2] / mod
  ]);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Line.prototype.translate" id="apidoc.element.sylvester.Line.prototype.translate">
        function <span class="apidocSignatureSpan">sylvester.Line.prototype.</span>translate
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translate = function (vector) {
  var V = vector.elements || vector;
  return Line.create([
    this.anchor.elements[0] + V[0],
    this.anchor.elements[1] + V[1],
    this.anchor.elements[2] + (V[2] || 0)
  ], this.direction);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.<span class="apidocCodeKeywordSpan">translate</span>(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Matrix" id="apidoc.module.sylvester.Matrix">module sylvester.Matrix</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Matrix" id="apidoc.element.sylvester.Matrix.Matrix">
        function <span class="apidocSignatureSpan">sylvester.</span>Matrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Matrix() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Diagonal" id="apidoc.element.sylvester.Matrix.Diagonal">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Diagonal
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Diagonal = function (elements) {
    var i = elements.length;
    var M = Matrix.I(i);
    while (i--) {
	M.elements[i][i] = elements[i];
    }
    return M;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Fill" id="apidoc.element.sylvester.Matrix.Fill">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Fill
        <span class="apidocSignatureSpan">(n, m, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fill = function (n, m, v) {
    if (arguments.length === 2) {
	v = m;
	m = n;
    }

    var els = [], i = n, j;

    while (i--) {
	j = m;
	els[i] = [];

	while (j--) {
	    els[i][j] = v;
	}
    }

    return Matrix.create(els);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.I" id="apidoc.element.sylvester.Matrix.I">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>I
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">I = function (n) {
    var els = [], i = n, j;
    while (i--) {
	j = n;
	els[i] = [];
	while (j--) {
	    els[i][j] = (i == j) ? 1 : 0;
	}
    }
    return Matrix.create(els);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    it(&#x27;should partial pivot&#x27;, function() {
        var B = $M([
            [3,  6,  -9],
            [-4, 1 , 10],
            [2,  5,  -3]
        ]);
	
	var P = Matrix.<span class="apidocCodeKeywordSpan">I</span>(3);
	B.partialPivot(1, 1, P, B);
	
	expect(B.eql($M([
            [-4,  1 ,  10],
	    [ 3,  6,  -9],
	    [ 2,  5,  -3]
	]))).toBeTruthy();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.One" id="apidoc.element.sylvester.Matrix.One">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>One
        <span class="apidocSignatureSpan">(n, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">One = function (n, m) {
    return Matrix.Fill(n, m, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

returns a vector of minimum values ([1 4]):

 $M([[1, 2, 3], [5, 4, 6]]).minColumns()

create a 2x3 matrix of ones:

 var Ones = Matrix.<span class="apidocCodeKeywordSpan">One</span>(2, 3);

LU decomposition (with partial pivoting)

var lu = A.lu();
console.log(lu.L);
console.log(lu.U);
console.log(lu.P);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Ones" id="apidoc.element.sylvester.Matrix.Ones">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Ones
        <span class="apidocSignatureSpan">(n, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Ones = function (n, m) {
    return Matrix.One(n, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Random" id="apidoc.element.sylvester.Matrix.Random">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Random
        <span class="apidocSignatureSpan">(n, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Random = function (n, m) {
    if (arguments.length === 1) m = n;
    return Matrix.Zero(n, m).map(
	function() { return Math.random(); }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Rotation" id="apidoc.element.sylvester.Matrix.Rotation">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Rotation
        <span class="apidocSignatureSpan">(theta, a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Rotation = function (theta, a) {
    if (!a) {
	return Matrix.create([
	    [Math.cos(theta), -Math.sin(theta)],
	    [Math.sin(theta), Math.cos(theta)]
	]);
    }
    var axis = a.dup();
    if (axis.elements.length != 3) { return null; }
    var mod = axis.modulus();
    var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;
    var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;
    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp
    // That proof rotates the co-ordinate system so theta
    // becomes -theta and sin becomes -sin here.
    return Matrix.create([
	[t * x * x + c, t * x * y - s * z, t * x * z + s * y],
	[t * x * y + s * z, t * y * y + c, t * y * z - s * x],
	[t * x * z - s * y, t * y * z + s * x, t * z * z + c]
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.plane = this.plane.translate(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.<span class="apidocCodeKeywordSpan">Rotation</span>(t, line.direction);
  this.vertices.each(function(node) {
    node.data.setElements(node.data.rotate(R, line).elements);
  });
  this.plane = this.plane.rotate(R, line);
  this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });
  return this;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.RotationX" id="apidoc.element.sylvester.Matrix.RotationX">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>RotationX
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RotationX = function (t) {
    var c = Math.cos(t), s = Math.sin(t);
    return Matrix.create([
	[1, 0, 0],
	[0, c, -s],
	[0, s, c]
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.RotationY" id="apidoc.element.sylvester.Matrix.RotationY">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>RotationY
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RotationY = function (t) {
    var c = Math.cos(t), s = Math.sin(t);
    return Matrix.create([
	[c, 0, s],
	[0, 1, 0],
	[-s, 0, c]
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.RotationZ" id="apidoc.element.sylvester.Matrix.RotationZ">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>RotationZ
        <span class="apidocSignatureSpan">(t)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RotationZ = function (t) {
    var c = Math.cos(t), s = Math.sin(t);
    return Matrix.create([
	[c, -s, 0],
	[s, c, 0],
	[0, 0, 1]
    ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Zero" id="apidoc.element.sylvester.Matrix.Zero">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Zero
        <span class="apidocSignatureSpan">(n, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Zero = function (n, m) {
    return Matrix.Fill(n, m, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Returns the centroid of the polygon. Requires division into
// triangles - use with caution
centroid: function() {
  if (this.isTriangle()) {
    var A = this.v(1).elements, B = this.v(2).elements, C = this.v(3).elements;
    return Vector.create([(A[0] + B[0] + C[0])/3, (A[1] + B[1] + C[1])/3, (A[2] + B[2] + C[2])/3]);
  } else {
    var A, M = 0, V = Vector.<span class="apidocCodeKeywordSpan">Zero</span>(3), P, C, trigs = this.trianglesForSurfaceIntegral();
    var i = trigs.length;
    while (i--) {
      A = trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
      M += A;
      P = V.elements;
      C = trigs[i].centroid().elements;
      V.setElements([P[0] + C[0] * A, P[1] + C[1] * A, P[2] + C[2] * A]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.Zeros" id="apidoc.element.sylvester.Matrix.Zeros">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>Zeros
        <span class="apidocSignatureSpan">(n, m)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Zeros = function (n, m) {
    return Matrix.Zero(n, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.create" id="apidoc.element.sylvester.Matrix.create">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>create
        <span class="apidocSignatureSpan">(aElements, ignoreLapack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (aElements, ignoreLapack) {
    var M = new Matrix().setElements(aElements);
    return M;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sylvester = require(&#x27;../lib/node-sylvester&#x27;),
Line = sylvester.Line,
LineSegment = sylvester.Line.Segment,
Vector = sylvester.Vector;

describe(&#x27;line segment&#x27;, function() {
    it(&#x27;should create&#x27;, function() {
	var lineSegment = Line.Segment.<span class="apidocCodeKeywordSpan">create</span>([1, 2], [5, 6]);
	expect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));
    })
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.loadFile" id="apidoc.element.sylvester.Matrix.loadFile">
        function <span class="apidocSignatureSpan">sylvester.Matrix.</span>loadFile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadFile = function (file) {
    var contents = fs.readFileSync(file, &#x27;utf-8&#x27;);
    var matrix = [];

    var rowArray = contents.split(&#x27;\n&#x27;);
    for (var i = 0; i &#x3c; rowArray.length; i++) {
	var d = rowArray[i].split(&#x27;,&#x27;);
	if (d.length &#x3e; 1) {
	    matrix.push(d);
	}
    }

    var M = new Matrix();
    return M.setElements(matrix);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Matrix.prototype" id="apidoc.module.sylvester.Matrix.prototype">module sylvester.Matrix.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.add" id="apidoc.element.sylvester.Matrix.prototype.add">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>add
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (matrix) {
	if(typeof(matrix) == &#x27;number&#x27;) {
	    return this.map(function(x, i, j) { return x + matrix});
	} else {
	    var M = matrix.elements || matrix;
	    if (typeof(M[0][0]) == &#x27;undefined&#x27;) { M = Matrix.create(M).elements; }
	    if (!this.isSameSizeAs(M)) { return null; }
	    return this.map(function(x, i, j) { return x + M[i - 1][j - 1]; });
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

divide matricies:

    A.div($M([[0.5, 1], [1, 2], [2, 3]]));

scalar addition/subtraction

    A.<span class="apidocCodeKeywordSpan">add</span>(1);
    A.subtract(1);

element-wise log:

    console.log(A.log());

element-wise multiplication:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.approxEql" id="apidoc.element.sylvester.Matrix.prototype.approxEql">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>approxEql
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">approxEql = function (matrix) {
	return this.eql(matrix, Sylvester.approxPrecision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		[-9, 4, 3,  9],
		[11, 3, 11, 3],
		[-4, 5, 3,  1]
	    ]);
	
	    var lu = A.lu();
	
	    expect(lu.L.<span class="apidocCodeKeywordSpan">approxEql</span>($M([
		[ 1, 0, 0, 0],
		[-0.818181818181818 , 1, 0, 0],
		[0.363636363636364, 0.140845070422535, 1, 0],
		[-0.363636363636364, 0.943661971830986, 0.921921921921922, 1]
	    ]))).toBeTruthy();
	
	    expect(lu.U.approxEql($M([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.augment" id="apidoc.element.sylvester.Matrix.prototype.augment">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>augment
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augment = function (matrix) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == &#x27;undefined&#x27;) { M = Matrix.create(M).elements; }
	var T = this.dup(), cols = T.elements[0].length;
	var i = T.elements.length, nj = M[0].length, j;
	if (i != M.length) { return null; }
	while (i--) {
	    j = nj;
	    while (j--) {
		T.elements[i][cols + j] = M[i][j];
	    }
	}
	return T;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

multiply all elements into a single scalar:

    a.product()

return a vector with the elements parameter on the bottom:

    a.<span class="apidocCodeKeywordSpan">augment</span>(elements)

=== Matrix

    var A = $M([[1, 2, 3], [4, 5, 6]]);

return subset of rows, columns:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.backSubstitute" id="apidoc.element.sylvester.Matrix.prototype.backSubstitute">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>backSubstitute
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backSubstitute = function (b) {
	var xa = [];

	for(var i = this.rows(); i &#x3e; 0; i--) {
	    var w = 0;

	    for(var j = this.cols(); j &#x3e; i; j--) {
		w += this.e(i, j) * xa[this.rows() - j];
	    }

	    xa.push((b.e(i) - w) / this.e(i, i));
	}

	return $V(xa.reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var L = $M([
	    [4, 4],
	    [0, 1],
	]);

	var b = $V([1, 1.5]);

	expect(L.<span class="apidocCodeKeywordSpan">backSubstitute</span>(b).eql($V([-1.25, 1.5]))).toBeTruthy();
    });

    it(&#x27;should solve&#x27;, function() {
	// 2x + 3y = 2
	// 4x + 4y = 1

	// x = -1.25
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.canMultiplyFromLeft" id="apidoc.element.sylvester.Matrix.prototype.canMultiplyFromLeft">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>canMultiplyFromLeft
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canMultiplyFromLeft = function (matrix) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == &#x27;undefined&#x27;) { M = Matrix.create(M).elements; }
	// this.columns should equal matrix.rows
	return (this.elements[0].length == M.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.col" id="apidoc.element.sylvester.Matrix.prototype.col">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>col
        <span class="apidocSignatureSpan">(j)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">col = function (j) {
	if (j &#x3e; this.elements[0].length) { return null; }
	var col = [], n = this.elements.length;
	for (var i = 0; i &#x3c; n; i++) { col.push(this.elements[i][j - 1]); }
	return $V(col);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.cols" id="apidoc.element.sylvester.Matrix.prototype.cols">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>cols
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cols = function () {
	return this.elements[0].length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.column" id="apidoc.element.sylvester.Matrix.prototype.column">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>column
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">column = function (n) {
	return this.col(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

it(&#x27;should create a 1\&#x27;s matrix&#x27;, function() {
	var Ones = Matrix.One(2, 3);
	expect(Ones.eql($M([[1,1,1], [1,1,1]]))).toBeTruthy();
});

it(&#x27;columns should be retrievable as vectors&#x27;, function() {
	expect(A.<span class="apidocCodeKeywordSpan">column</span>(2).eql($V([2, 5]))).toBeTruthy();
});

it(&#x27;should log&#x27;, function() {
	expect(A.log().eql($M([[0, 0.6931471805599453, 1.0986122886681098],
			       [1.3862943611198906, 1.6094379124341003, 1.791759469228055]]))).toBeTruthy();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.det" id="apidoc.element.sylvester.Matrix.prototype.det">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>det
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">det = function () { return this.determinant(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.determinant" id="apidoc.element.sylvester.Matrix.prototype.determinant">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>determinant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">determinant = function () {
	if (!this.isSquare()) { return null; }
	if (this.cols == 1 &#x26;&#x26; this.rows == 1) { return this.row(1); }
	if (this.cols == 0 &#x26;&#x26; this.rows == 0) { return 1; }
	var M = this.toRightTriangular();
	var det = M.elements[0][0], n = M.elements.length;
	for (var i = 1; i &#x3c; n; i++) {
	    det = det * M.elements[i][i];
	}
	return det;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.diagonal" id="apidoc.element.sylvester.Matrix.prototype.diagonal">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>diagonal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diagonal = function () {
	if (!this.isSquare) { return null; }
	var els = [], n = this.elements.length;
	for (var i = 0; i &#x3c; n; i++) {
	    els.push(this.elements[i][i]);
	}
	return $V(els);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.dimensions" id="apidoc.element.sylvester.Matrix.prototype.dimensions">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>dimensions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dimensions = function () {
	return {rows: this.elements.length, cols: this.elements[0].length};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.div" id="apidoc.element.sylvester.Matrix.prototype.div">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>div
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (matrix) {
	return this.mulOp(matrix, function(x, y) { return x / y});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return subset of rows, columns:

    // startRow, endRow, startCol, endCol
    A.slice(2, 3, 2, 3);

divide matricies:

    A.<span class="apidocCodeKeywordSpan">div</span>($M([[0.5, 1], [1, 2], [2, 3]]));

scalar addition/subtraction

    A.add(1);
    A.subtract(1);

element-wise log:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.dup" id="apidoc.element.sylvester.Matrix.prototype.dup">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>dup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dup = function () {
	return Matrix.create(this.elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
  var poly = this.<span class="apidocCodeKeywordSpan">dup</span>(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.e" id="apidoc.element.sylvester.Matrix.prototype.e">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>e
        <span class="apidocSignatureSpan">(i, j)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (i, j) {
	if (i &#x3c; 1 || i &#x3e; this.elements.length || j &#x3c; 1 || j &#x3e; this.elements[0].length) { return null; }
	return this.elements[i - 1][j - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.elementMultiply" id="apidoc.element.sylvester.Matrix.prototype.elementMultiply">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>elementMultiply
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elementMultiply = function (v) {
    return this.map(function(k, i, j) {
        return v.e(i, j) * k;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

norm computation:

    console.log(a.norm());

element-wise multiplication:

    a.<span class="apidocCodeKeywordSpan">elementMultiply</span>(vector);

element-wise division:

    a.elementDivide(vector);

remove first n nodes:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.eql" id="apidoc.element.sylvester.Matrix.prototype.eql">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>eql
        <span class="apidocSignatureSpan">(matrix, precision)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eql = function (matrix, precision) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == &#x27;undefined&#x27;) { M = Matrix.create(M).elements; }
	if (this.elements.length != M.length ||
        this.elements[0].length != M[0].length) { return false; }
	var i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) { j = nj;
		      while (j--) {
			  if (Math.abs(this.elements[i][j] - M[i][j]) &#x3e; (precision || Sylvester.precision)) { return false; }
		      }
		    }
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var svd = A.svd();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).pcaProject(1).<span class="apidocCodeKeywordSpan">eql</span>($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.pcaRecover(pca.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.forwardSubstitute" id="apidoc.element.sylvester.Matrix.prototype.forwardSubstitute">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>forwardSubstitute
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forwardSubstitute = function (b) {
	var xa = [];

	for(var i = 1; i &#x3c;= this.rows(); i++) {
	    var w = 0;

	    for(var j = 1; j &#x3c; i; j++) {
		w += this.e(i, j) * xa[j - 1];
	    }

	    xa.push((b.e(i) - w) / this.e(i, i));
	}

	return $V(xa);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	    [1, 0, 0],
	    [0.5, 1, 0],
	    [2, 3, 1]
	]);

	var b = $V([1, 2, 3]);

	expect(L.<span class="apidocCodeKeywordSpan">forwardSubstitute</span>(b).eql($V([1, 1.5, -3.5]))).toBeTruthy();
    });

    it(&#x27;should back substitute&#x27;, function() {
	var L = $M([
	    [4, 4],
	    [0, 1],
	]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.indexOf" id="apidoc.element.sylvester.Matrix.prototype.indexOf">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (x) {
	var index = null, ni = this.elements.length, i, nj = this.elements[0].length, j;
	for (i = 0; i &#x3c; ni; i++) {
	    for (j = 0; j &#x3c; nj; j++) {
		if (this.elements[i][j] == x) { return {i: i + 1, j: j + 1}; }
	    }
	}
	return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.inspect" id="apidoc.element.sylvester.Matrix.prototype.inspect">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
	var matrix_rows = [];
	var n = this.elements.length;
	for (var i = 0; i &#x3c; n; i++) {
	    matrix_rows.push($V(this.elements[i]).inspect());
	}
	return matrix_rows.join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.cached[key] = value;
  return value;
},

// Returns a string representation of the polygon&#x27;s vertices.
inspect: function() {
  var points = [];
  this.vertices.each(function(node) { points.push(node.data.<span class="apidocCodeKeywordSpan">inspect</span>()); });
  return points.join(&#x27; -&#x3e; &#x27;);
}
};

// Constructor function
Polygon.create = function(points, plane) {
var P = new Polygon();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.inv" id="apidoc.element.sylvester.Matrix.prototype.inv">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>inv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inv = function () { return this.inverse(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.inverse" id="apidoc.element.sylvester.Matrix.prototype.inverse">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>inverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverse = function () {
	if (!this.isSquare() || this.isSingular()) { return null; }
	var n = this.elements.length, i = n, j;
	var M = this.augment(Matrix.I(n)).toRightTriangular();
	var np = M.elements[0].length, p, els, divisor;
	var inverse_elements = [], new_element;
	// Matrix is non-singular so there will be no zeros on the diagonal
	// Cycle through rows from last to first
	while (i--) {
	    // First, normalise diagonal elements to 1
	    els = [];
	    inverse_elements[i] = [];
	    divisor = M.elements[i][i];
	    for (p = 0; p &#x3c; np; p++) {
    new_element = M.elements[i][p] / divisor;
		els.push(new_element);
		// Shuffle off the current row of the right hand side into the results
		// array as it will not be modified by later runs through this loop
		if (p &#x3e;= n) { inverse_elements[i].push(new_element); }
	    }
	    M.elements[i] = els;
	    // Then, subtract this row from those above it to
	    // give the identity matrix on the left hand side
	    j = i;
	    while (j--) {
		els = [];
		for (p = 0; p &#x3c; np; p++) {
		    els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);
		}
		M.elements[j] = els;
	    }
	}
	return Matrix.create(inverse_elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.isSameSizeAs" id="apidoc.element.sylvester.Matrix.prototype.isSameSizeAs">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>isSameSizeAs
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSameSizeAs = function (matrix) {
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == &#x27;undefined&#x27;) { M = Matrix.create(M).elements; }
	return (this.elements.length == M.length &#x26;&#x26;
		this.elements[0].length == M[0].length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.isSingular" id="apidoc.element.sylvester.Matrix.prototype.isSingular">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>isSingular
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSingular = function () {
	return (this.isSquare() &#x26;&#x26; this.determinant() === 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.isSquare" id="apidoc.element.sylvester.Matrix.prototype.isSquare">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>isSquare
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSquare = function () {
	return (this.elements.length == this.elements[0].length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.log" id="apidoc.element.sylvester.Matrix.prototype.log">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
	return this.map(function(x) { return Math.log(x); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
=== Vector

    require(&#x27;sylvester&#x27;);
    var a = $V([1, 2, 3]);

element-wise log:

    console.<span class="apidocCodeKeywordSpan">log</span>(a.log());

norm computation:

    console.log(a.norm());

element-wise multiplication:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.lu" id="apidoc.element.sylvester.Matrix.prototype.lu">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>lu
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function luJs() {
    var A = this.dup();
    var L = Matrix.I(A.rows());
    var P = Matrix.I(A.rows());
    var U = Matrix.Zeros(A.rows(), A.cols());
    var p = 1;

    for(var k = 1; k &#x3c;= Math.min(A.cols(), A.rows()); k++) {
	P = A.partialPivot(k, p, P, A, L);
	
	for(var i = k + 1; i &#x3c;= A.rows(); i++) {
	    var l = A.e(i, p) / A.e(k, p);
	    L.elements[i - 1][k - 1] = l;
	
	    for(var j = k + 1 ; j &#x3c;= A.cols(); j++) {
		A.elements[i - 1][j - 1] -= A.e(k, j) * l;
	    }
	}
	
	for(var j = k; j &#x3c;= A.cols(); j++) {
	    U.elements[k - 1][j - 1] = A.e(k, j);
	}

	if(p &#x3c; A.cols())
	    p++;
    }

    return {L: L, U: U, P: P};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

create a 2x3 matrix of ones:

var Ones = Matrix.One(2, 3);

LU decomposition (with partial pivoting)

   var lu = A.<span class="apidocCodeKeywordSpan">lu</span>();
   console.log(lu.L);
   console.log(lu.U);
   console.log(lu.P);

QR decomposition (feature still inefficient and experimental, but uses pure javascript):

var qr = A.qr();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.luJs" id="apidoc.element.sylvester.Matrix.prototype.luJs">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>luJs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function luJs() {
    var A = this.dup();
    var L = Matrix.I(A.rows());
    var P = Matrix.I(A.rows());
    var U = Matrix.Zeros(A.rows(), A.cols());
    var p = 1;

    for(var k = 1; k &#x3c;= Math.min(A.cols(), A.rows()); k++) {
	P = A.partialPivot(k, p, P, A, L);
	
	for(var i = k + 1; i &#x3c;= A.rows(); i++) {
	    var l = A.e(i, p) / A.e(k, p);
	    L.elements[i - 1][k - 1] = l;
	
	    for(var j = k + 1 ; j &#x3c;= A.cols(); j++) {
		A.elements[i - 1][j - 1] -= A.e(k, j) * l;
	    }
	}
	
	for(var j = k; j &#x3c;= A.cols(); j++) {
	    U.elements[k - 1][j - 1] = A.e(k, j);
	}

	if(p &#x3c; A.cols())
	    p++;
    }

    return {L: L, U: U, P: P};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	    var D = $M([
		[3, 6],
		[2, 3],
		[4, 3],
		[2, 120],
	    ]);

	    var lu = D.<span class="apidocCodeKeywordSpan">luJs</span>();
	    expect(lu.P.x((lu.L.x(lu.U))).eql(D)).toBeTruthy();

	    lu = D.luPack();
	    expect(lu.P.x((lu.L.x(lu.U))).eql(D)).toBeTruthy();
	});

	it(&#x27;should perform LU decomp&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.luPack" id="apidoc.element.sylvester.Matrix.prototype.luPack">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>luPack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function luPack() {
    var lu = lapack.lu(this.elements);
    return {
	L: $M(lu.L),
	U: $M(lu.U),
	P: $M(lu.P)
	// don&#x27;t pass back IPIV
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		[4, 3],
		[2, 120],
	    ]);

	    var lu = D.luJs();
	    expect(lu.P.x((lu.L.x(lu.U))).eql(D)).toBeTruthy();

	    lu = D.<span class="apidocCodeKeywordSpan">luPack</span>();
	    expect(lu.P.x((lu.L.x(lu.U))).eql(D)).toBeTruthy();
	});

	it(&#x27;should perform LU decomp&#x27;, function() {
	    var A = $M([
		[4,  2, 1,  4],
		[-9, 4, 3,  9],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.map" id="apidoc.element.sylvester.Matrix.prototype.map">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>map
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (fn) {
var els = [], i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) { j = nj;
		      els[i] = [];
		      while (j--) {
			  els[i][j] = fn(this.elements[i][j], i + 1, j + 1);
		      }
		    }
	return Matrix.create(els);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.max" id="apidoc.element.sylvester.Matrix.prototype.max">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () {
	var m = 0, i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) {
	    j = nj;
	    while (j--) {
		if (Math.abs(this.elements[i][j]) &#x3e; Math.abs(m)) { m = this.elements[i][j]; }
	    }
	}
	return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.maxColumnIndexes" id="apidoc.element.sylvester.Matrix.prototype.maxColumnIndexes">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>maxColumnIndexes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxColumnIndexes = function () {
	var maxes = [];

	for(var i = 1; i &#x3c;= this.rows(); i++) {
	    var max = null;
	    var maxIndex = -1;

	    for(var j = 1; j &#x3c;= this.cols(); j++) {
		if(max === null || this.e(i, j) &#x3e; max) {
		    max = this.e(i, j);
		    maxIndex = j;
		}
	    }

	    maxes.push(maxIndex);
	}

	return $V(maxes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

add all	elements into a	single scalar:

    A.sum()

returns a vector of the indexes of maximum values ([3 3]):

    $M([[1, 2, 3], [5, 4, 6]]).<span class="apidocCodeKeywordSpan">maxColumnIndexes</span>()

returns a vector of minimum column indexes ([1 2]):

    $M([[1, 2, 3], [5, 4, 6]]).minColumnIndexes();

returns a vector of max values ([3 6]):
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.maxColumns" id="apidoc.element.sylvester.Matrix.prototype.maxColumns">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>maxColumns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxColumns = function () {
	var maxes = [];

	for(var i = 1; i &#x3c;= this.rows(); i++) {
	    var max = null;

	    for(var j = 1; j &#x3c;= this.cols(); j++) {
		if(max === null || this.e(i, j) &#x3e; max) {
		    max = this.e(i, j);
		}
	    }

	    maxes.push(max);
	}

	return $V(maxes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

returns a vector of minimum column indexes ([1 2]):

    $M([[1, 2, 3], [5, 4, 6]]).minColumnIndexes();

returns a vector of max values ([3 6]):

    $M([[1, 2, 3], [5, 4, 6]]).<span class="apidocCodeKeywordSpan">maxColumns</span>()

returns a vector of minimum values ([1 4]):

    $M([[1, 2, 3], [5, 4, 6]]).minColumns()

create a 2x3 matrix of ones:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.mean" id="apidoc.element.sylvester.Matrix.prototype.mean">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>mean
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mean = function () {
  var dim = this.dimensions();
  var r = [];
  for (var i = 1; i &#x3c;= dim.cols; i++) {
    r.push(this.col(i).sum() / dim.rows);
  }
  return $V(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.minColumnIndexes" id="apidoc.element.sylvester.Matrix.prototype.minColumnIndexes">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>minColumnIndexes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minColumnIndexes = function () {
	var mins = [];

	for(var i = 1; i &#x3c;= this.rows(); i++) {
	    var min = null;
	    var minIndex = -1;

	    for(var j = 1; j &#x3c;= this.cols(); j++) {
		if(min === null || this.e(i, j) &#x3c; min) {
		    min = this.e(i, j);
		    minIndex = j;
		}
	    }

	    mins.push(minIndex);
	}

	return $V(mins);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

returns a vector of the indexes of maximum values ([3 3]):

    $M([[1, 2, 3], [5, 4, 6]]).maxColumnIndexes()

returns a vector of minimum column indexes ([1 2]):

    $M([[1, 2, 3], [5, 4, 6]]).<span class="apidocCodeKeywordSpan">minColumnIndexes</span>();

returns a vector of max values ([3 6]):

    $M([[1, 2, 3], [5, 4, 6]]).maxColumns()

returns a vector of minimum values ([1 4]):
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.minColumns" id="apidoc.element.sylvester.Matrix.prototype.minColumns">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>minColumns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minColumns = function () {
	var mins = [];

	for(var i = 1; i &#x3c;= this.rows(); i++) {
	    var min = null;

	    for(var j = 1; j &#x3c;= this.cols(); j++) {
		if(min === null || this.e(i, j) &#x3c; min) {
		    min = this.e(i, j);
		}
	    }

	    mins.push(min);
	}

	return $V(mins);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

returns a vector of max values ([3 6]):

    $M([[1, 2, 3], [5, 4, 6]]).maxColumns()

returns a vector of minimum values ([1 4]):

    $M([[1, 2, 3], [5, 4, 6]]).<span class="apidocCodeKeywordSpan">minColumns</span>()

create a 2x3 matrix of ones:

    var Ones = Matrix.One(2, 3);

LU decomposition (with partial pivoting)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.minor" id="apidoc.element.sylvester.Matrix.prototype.minor">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>minor
        <span class="apidocSignatureSpan">(a, b, c, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minor = function (a, b, c, d) {
	var elements = [], ni = c, i, nj, j;
	var rows = this.elements.length, cols = this.elements[0].length;
	while (ni--) {
	    i = c - ni - 1;
	    elements[i] = [];
	    nj = d;
	    while (nj--) {
		j = d - nj - 1;
		elements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];
	    }
	}
	return Matrix.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.mulOp" id="apidoc.element.sylvester.Matrix.prototype.mulOp">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>mulOp
        <span class="apidocSignatureSpan">(matrix, op)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mulOp = function (matrix, op) {
	if (!matrix.elements) {
	    return this.map(function(x) { return op(x, matrix); });
	}

	var returnVector = matrix.modulus ? true : false;
	var M = matrix.elements || matrix;
	if (typeof(M[0][0]) == &#x27;undefined&#x27;)
	    M = Matrix.create(M).elements;
	if (!this.canMultiplyFromLeft(M))
	    return null;
	var e = this.elements, rowThis, rowElem, elements = [],
    sum, m = e.length, n = M[0].length, o = e[0].length, i = m, j, k;

	while (i--) {
        rowElem = [];
        rowThis = e[i];
        j = n;

        while (j--) {
		sum = 0;
		k = o;

		while (k--) {
                sum += op(rowThis[k], M[k][j]);
		}

		rowElem[j] = sum;
        }

        elements[i] = rowElem;
	}

	var M = Matrix.create(elements);
	return returnVector ? M.col(1) : M;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.multiply" id="apidoc.element.sylvester.Matrix.prototype.multiply">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>multiply
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (matrix) {
	return this.mulOp(matrix, function(x, y) { return x * y});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.partialPivot" id="apidoc.element.sylvester.Matrix.prototype.partialPivot">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>partialPivot
        <span class="apidocSignatureSpan">(k, j, P, A, L)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">partialPivot = function (k, j, P, A, L) {
	var maxIndex = 0;
	var maxValue = 0;

	for(var i = k; i &#x3c;= A.rows(); i++) {
	    if(Math.abs(A.e(i, j)) &#x3e; maxValue) {
		maxValue = Math.abs(A.e(k, j));
		maxIndex = i;
	    }
	}

	if(maxIndex != k) {
	    var tmp = A.elements[k - 1];
	    A.elements[k - 1] = A.elements[maxIndex - 1];
	    A.elements[maxIndex - 1] = tmp;
	
	    P.elements[k - 1][k - 1] = 0;
	    P.elements[k - 1][maxIndex - 1] = 1;
	    P.elements[maxIndex - 1][maxIndex - 1] = 0;
	    P.elements[maxIndex - 1][k - 1] = 1;
	}
	
	return P;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var B = $M([
            [3,  6,  -9],
            [-4, 1 , 10],
            [2,  5,  -3]
        ]);
	
	var P = Matrix.I(3);
	B.<span class="apidocCodeKeywordSpan">partialPivot</span>(1, 1, P, B);
	
	expect(B.eql($M([
            [-4,  1 ,  10],
	    [ 3,  6,  -9],
	    [ 2,  5,  -3]
	]))).toBeTruthy();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.pcaProject" id="apidoc.element.sylvester.Matrix.prototype.pcaProject">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>pcaProject
        <span class="apidocSignatureSpan">(k, U)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pcaProject = function (k, U) {
	var U = U || pca(this).U;
	var Ureduce= U.slice(1, U.rows(), 1, k);
	return {Z: this.x(Ureduce), U: U};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var svd = A.svd();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).<span class="apidocCodeKeywordSpan">pcaProject</span>(1).eql($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.pcaRecover(pca.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.pcaRecover" id="apidoc.element.sylvester.Matrix.prototype.pcaRecover">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>pcaRecover
        <span class="apidocSignatureSpan">(U)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pcaRecover = function (U) {
	var k = this.cols();
	var Ureduce = U.slice(1, U.rows(), 1, k);
	return this.x(Ureduce.transpose());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var A = $M([[1, 2], [5, 7]]).pcaProject(1).eql($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.<span class="apidocCodeKeywordSpan">pcaRecover</span>(pca.U);

Solving systems of equations

// sovle Ax = b for x
var A = $M([[2, 4], [2, 1]]);
var b = $V([1, 0]);
console.log(A.solve(b));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.qr" id="apidoc.element.sylvester.Matrix.prototype.qr">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>qr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function qrJs() {
    var m = this.rows();
    var n = this.cols();
    var Q = Matrix.I(m);
    var A = this;

    for(var k = 1; k &#x3c; Math.min(m, n); k++) {
	var ak = A.slice(k, 0, k, k).col(1);
	var oneZero = [1];
	
	while(oneZero.length &#x3c;=  m - k)
	    oneZero.push(0);
	
	oneZero = $V(oneZero);
	var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));
	var Vk = $M(vk);
	var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));
	var Qk = identSize(Hk, m, n, k);
	A = Qk.x(A);
	// slow way to compute Q
	Q = Q.x(Qk);
    }

    return {Q: Q, R: A};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   var lu = A.lu();
   console.log(lu.L);
   console.log(lu.U);
   console.log(lu.P);

QR decomposition (feature still inefficient and experimental, but uses pure javascript):

var qr = A.<span class="apidocCodeKeywordSpan">qr</span>();
console.log(qr.Q);
console.log(qr.R);

SVD decomposition (feature still inefficient and experimental, but uses pure javascript):

var svd = A.svd();
console.log(svd.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.qrJs" id="apidoc.element.sylvester.Matrix.prototype.qrJs">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>qrJs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function qrJs() {
    var m = this.rows();
    var n = this.cols();
    var Q = Matrix.I(m);
    var A = this;

    for(var k = 1; k &#x3c; Math.min(m, n); k++) {
	var ak = A.slice(k, 0, k, k).col(1);
	var oneZero = [1];
	
	while(oneZero.length &#x3c;=  m - k)
	    oneZero.push(0);
	
	oneZero = $V(oneZero);
	var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));
	var Vk = $M(vk);
	var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));
	var Qk = identSize(Hk, m, n, k);
	A = Qk.x(A);
	// slow way to compute Q
	Q = Q.x(Qk);
    }

    return {Q: Q, R: A};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                   [-0.6324555320336759, 0.16195526603578317, 0.048393391849582745, 0.7559289460184544]]);
    var Rout = $M([[-3.1622776601683795, 0.9486832980505139, -3.478505426185217, -2.8460498941515415],
                   [1.91055907392895e-17, -2.4698178070456938, -1.7410191098846692, 0.1214664495268375],
                   [-2.254600901479451e-16, 2.0686390257580927e-16, 1.6937687147353957, 0.7742942695933234],
                   [3.446764628337833e-17, 8.098938594673387e-17, 2.220446049250313e-16, -1.1338934190276815]]);

    it(&#x27;should qr from javascript&#x27;, function() {
	var qr = QRin.<span class="apidocCodeKeywordSpan">qrJs</span>();
	expect(qr.Q.eql(Qout)).toBeTruthy();
	expect(qr.R.eql(Rout)).toBeTruthy();
    });

    it(&#x27;should qr from lapack&#x27;, function() {
	var qr = QRin.qrPack();
	expect(qr.Q.eql(Qout)).toBeTruthy();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.qrPack" id="apidoc.element.sylvester.Matrix.prototype.qrPack">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>qrPack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function qrPack() {
    var qr = lapack.qr(this.elements);

    return {
	Q: $M(qr.Q),
	R: $M(qr.R)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    it(&#x27;should qr from javascript&#x27;, function() {
	var qr = QRin.qrJs();
	expect(qr.Q.eql(Qout)).toBeTruthy();
	expect(qr.R.eql(Rout)).toBeTruthy();
    });

    it(&#x27;should qr from lapack&#x27;, function() {
	var qr = QRin.<span class="apidocCodeKeywordSpan">qrPack</span>();
	expect(qr.Q.eql(Qout)).toBeTruthy();
	expect(qr.R.eql(Rout)).toBeTruthy();
    });

    it(&#x27;should create a 1\&#x27;s matrix&#x27;, function() {
	var Ones = Matrix.One(2, 3);
	expect(Ones.eql($M([[1,1,1], [1,1,1]]))).toBeTruthy();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.rank" id="apidoc.element.sylvester.Matrix.prototype.rank">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>rank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rank = function () {
	var M = this.toRightTriangular(), rank = 0;
	var i = this.elements.length, nj = this.elements[0].length, j;
	while (i--) {
	    j = nj;
	    while (j--) {
		if (Math.abs(M.elements[i][j]) &#x3e; Sylvester.precision) { rank++; break; }
	    }
	}
	return rank;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.rk" id="apidoc.element.sylvester.Matrix.prototype.rk">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>rk
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rk = function () { return this.rank(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.round" id="apidoc.element.sylvester.Matrix.prototype.round">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
	return this.map(function(x) { return Math.round(x); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.row" id="apidoc.element.sylvester.Matrix.prototype.row">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>row
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">row = function (i) {
	if (i &#x3e; this.elements.length) { return null; }
	return $V(this.elements[i - 1]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.rows" id="apidoc.element.sylvester.Matrix.prototype.rows">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>rows
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rows = function () {
	return this.elements.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.setElements" id="apidoc.element.sylvester.Matrix.prototype.setElements">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>setElements
        <span class="apidocSignatureSpan">(els)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setElements = function (els) {
	var i, j, elements = els.elements || els;
	if (typeof(elements[0][0]) != &#x27;undefined&#x27;) {
	    i = elements.length;
	    this.elements = [];
	    while (i--) {
		j = elements[i].length;
		this.elements[i] = [];
		while (j--) {
		    this.elements[i][j] = elements[i][j];
		}
	    }
	    return this;
	}
	var n = elements.length;
	this.elements = [];
	for (i = 0; i &#x3c; n; i++) {
	    this.elements.push([elements[i]]);
	}
	return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.<span class="apidocCodeKeywordSpan">setElements</span>([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.translate(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.slice" id="apidoc.element.sylvester.Matrix.prototype.slice">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>slice
        <span class="apidocSignatureSpan">(startRow, endRow, startCol, endCol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (startRow, endRow, startCol, endCol) {
	var x = [];
	
	if(endRow == 0)
	    endRow = this.rows();
	
	if(endCol == 0)
	    endCol = this.cols();

	for(i = startRow; i &#x3c;= endRow; i++) {
	    var row = [];

	    for(j = startCol; j &#x3c;= endCol; j++) {
		row.push(this.e(i, j));
	    }

	    x.push(row);
	}

	return $M(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
=== Matrix

    var A = $M([[1, 2, 3], [4, 5, 6]]);

return subset of rows, columns:

    // startRow, endRow, startCol, endCol
    A.<span class="apidocCodeKeywordSpan">slice</span>(2, 3, 2, 3);

divide matricies:

    A.div($M([[0.5, 1], [1, 2], [2, 3]]));

scalar addition/subtraction
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.snapTo" id="apidoc.element.sylvester.Matrix.prototype.snapTo">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>snapTo
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">snapTo = function (x) {
	return this.map(function(p) {
	    return (Math.abs(p - x) &#x3c;= Sylvester.precision) ? x : p;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var A = $M([[1, 2, 3], [4, 5, 6]]);
	var B = $M([[1, 2, 3], [4, 5, 7]]);

	expect(A.eql(B)).toBeFalsy();
});

it(&#x27;should snap&#x27;, function() {
	expect($M([[1, 1.1, 1.00000001], [4, 5, 6]]).<span class="apidocCodeKeywordSpan">snapTo</span>(1).eql(
	    $M([[1, 1.1, 1], [4, 5, 6]]))).toBeTruthy();
});

it(&#x27;should compute the minimum index of matrix rows&#x27;, function() {
	expect($M([[1, 2, 3], [2, 1, 3], [2, 1, 0]]).minColumnIndexes().eql($V([2, 1, 3])));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.solve" id="apidoc.element.sylvester.Matrix.prototype.solve">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>solve
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solve = function (b) {
	var lu = this.lu();
	b = lu.P.x(b);
	var y = lu.L.forwardSubstitute(b);
	var x = lu.U.backSubstitute(y);
	return lu.P.x(x);
	//return this.inv().x(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var A = Z.pcaRecover(pca.U);

Solving systems of equations

    // sovle Ax = b for x
    var A = $M([[2, 4], [2, 1]]);
    var b = $V([1, 0]);
    console.log(A.<span class="apidocCodeKeywordSpan">solve</span>(b));

== Old Stuff

Below is a basic illustration of standard matrix/vector math using the standard
Sylvester API. This documentation is rather incomplete and for further details please consult {the official sylvester API documentation
}[http://sylvester.jcoglan.com/docs] at http://sylvester.jcoglan.com/docs.

=== Vectors
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.subtract" id="apidoc.element.sylvester.Matrix.prototype.subtract">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>subtract
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (matrix) {
	if(typeof(matrix) == &#x27;number&#x27;) {
	    return this.map(function(x, i, j) { return x - matrix});
	} else {
	    var M = matrix.elements || matrix;
	    if (typeof(M[0][0]) == &#x27;undefined&#x27;) { M = Matrix.create(M).elements; }
	    if (!this.isSameSizeAs(M)) { return null; }
	    return this.map(function(x, i, j) { return x - M[i - 1][j - 1]; });
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
divide matricies:

    A.div($M([[0.5, 1], [1, 2], [2, 3]]));

scalar addition/subtraction

    A.add(1);
    A.<span class="apidocCodeKeywordSpan">subtract</span>(1);

element-wise log:

    console.log(A.log());

element-wise multiplication:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.sum" id="apidoc.element.sylvester.Matrix.prototype.sum">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>sum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function () {
    var sum = 0;

    this.map(function(x) { sum += x;});

    return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return vector with first n nodes:

    a.top(n);

add all elements into a single scalar:

    a.<span class="apidocCodeKeywordSpan">sum</span>()

multiply all elements into a single scalar:

    a.product()

return a vector with the elements parameter on the bottom:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.svd" id="apidoc.element.sylvester.Matrix.prototype.svd">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>svd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function svdJs() {
    var A = this;
    var V = Matrix.I(A.rows());
    var S = A.transpose();
    var U = Matrix.I(A.cols());
    var err = Number.MAX_VALUE;
    var i = 0;
    var maxLoop = 100;

    while(err &#x3e; 2.2737e-13 &#x26;&#x26; i &#x3c; maxLoop) {
        var qr = S.transpose().qrJs();
        S = qr.R;
        V = V.x(qr.Q);
        qr = S.transpose().qrJs();
        U = U.x(qr.Q);
        S = qr.R;

        var e = S.triu(1).unroll().norm();
        var f = S.diagonal().norm();

        if(f == 0)
            f = 1;

        err = e / f;

        i++;
    }

    var ss = S.diagonal();
    var s = [];

    for(var i = 1; i &#x3c;= ss.cols(); i++) {
        var ssn = ss.e(i);
        s.push(Math.abs(ssn));

        if(ssn &#x3c; 0) {
            for(var j = 0; j &#x3c; U.rows(); j++) {
                V.elements[j][i - 1] = -(V.elements[j][i - 1]);
            }
        }
    }

    return {U: U, S: $V(s).toDiagonalMatrix(), V: V};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var qr = A.qr();
console.log(qr.Q);
console.log(qr.R);

SVD decomposition (feature still inefficient and experimental, but uses pure javascript):

var svd = A.<span class="apidocCodeKeywordSpan">svd</span>();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).pcaProject(1).eql($M([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.svdJs" id="apidoc.element.sylvester.Matrix.prototype.svdJs">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>svdJs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function svdJs() {
    var A = this;
    var V = Matrix.I(A.rows());
    var S = A.transpose();
    var U = Matrix.I(A.cols());
    var err = Number.MAX_VALUE;
    var i = 0;
    var maxLoop = 100;

    while(err &#x3e; 2.2737e-13 &#x26;&#x26; i &#x3c; maxLoop) {
        var qr = S.transpose().qrJs();
        S = qr.R;
        V = V.x(qr.Q);
        qr = S.transpose().qrJs();
        U = U.x(qr.Q);
        S = qr.R;

        var e = S.triu(1).unroll().norm();
        var f = S.diagonal().norm();

        if(f == 0)
            f = 1;

        err = e / f;

        i++;
    }

    var ss = S.diagonal();
    var s = [];

    for(var i = 1; i &#x3c;= ss.cols(); i++) {
        var ssn = ss.e(i);
        s.push(Math.abs(ssn));

        if(ssn &#x3c; 0) {
            for(var j = 0; j &#x3c; U.rows(); j++) {
                V.elements[j][i - 1] = -(V.elements[j][i - 1]);
            }
        }
    }

    return {U: U, S: $V(s).toDiagonalMatrix(), V: V};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	[ 1, -1, 2,  2],
	[-1,  2, 1, -1],
	[ 2,  1, 3,  2],
	[ 2, -1, 2,  1]
    ]);

    it(&#x27;should svd&#x27;, function() {
	var svd = ASVD.<span class="apidocCodeKeywordSpan">svdJs</span>();	
	expect(svd.U.eql(U)).toBeTruthy();
	expect(svd.S.eql(S)).toBeTruthy();
	expect(svd.V.eql(V)).toBeTruthy();
    });

    it(&#x27;should have matching svds for js and lapack&#x27;, function() {
	var svdJs = ASVD.svdJs();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.svdPack" id="apidoc.element.sylvester.Matrix.prototype.svdPack">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>svdPack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function svdPack() {
    var result = lapack.sgesvd(&#x27;A&#x27;, &#x27;A&#x27;, this.elements);

    return {
        U: $M(result.U),
        S: $M(result.S).column(1).toDiagonalMatrix(),
	V: $M(result.VT).transpose()
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	expect(svd.U.eql(U)).toBeTruthy();
	expect(svd.S.eql(S)).toBeTruthy();
	expect(svd.V.eql(V)).toBeTruthy();
});

it(&#x27;should have matching svds for js and lapack&#x27;, function() {
	var svdJs = ASVD.svdJs();	
	var svdPack = ASVD.<span class="apidocCodeKeywordSpan">svdPack</span>();

	expect(svdJs.U.eql(svdPack.U)).toBeTruthy();
	expect(svdJs.S.eql(svdPack.S)).toBeTruthy();
	expect(svdJs.V.eql(svdPack.V)).toBeTruthy();
});

var QRin = $M([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.toArray" id="apidoc.element.sylvester.Matrix.prototype.toArray">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
	var matrix_rows = [];
	var n = this.elements.length;
	for (var i = 0; i &#x3c; n; i++) {
    matrix_rows.push(this.elements[i]);
	}
  return matrix_rows;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Need to do this to renumber the remaining vertices
  triangles.push(Polygon.create(poly.vertices, this.plane));
  return triangles;
},

// Sets the polygon&#x27;s vertices
setVertices: function(points, plane) {
  var pointSet = points.toArray ? points.<span class="apidocCodeKeywordSpan">toArray</span>() : points;
  this.plane = (plane &#x26;&#x26; plane.normal) ? plane.dup() : Plane.fromPoints(pointSet);
  if (this.plane === null) { return null; }
  this.vertices = new LinkedList.Circular();
  // Construct linked list of vertices. If each point is already a polygon
  // vertex, we reference it rather than creating a new vertex.
  var i = pointSet.length, newVertex;
  while (i--) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.toRightTriangular" id="apidoc.element.sylvester.Matrix.prototype.toRightTriangular">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>toRightTriangular
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toRightTriangular = function () {
	var M = this.dup(), els;
	var n = this.elements.length, i, j, np = this.elements[0].length, p;
	for (i = 0; i &#x3c; n; i++) {
	    if (M.elements[i][i] == 0) {
		for (j = i + 1; j &#x3c; n; j++) {
		    if (M.elements[j][i] != 0) {
			els = [];
			for (p = 0; p &#x3c; np; p++) { els.push(M.elements[i][p] + M.elements[j][p]); }
			M.elements[i] = els;
			break;
		    }
		}
	    }
	    if (M.elements[i][i] != 0) {
		for (j = i + 1; j &#x3c; n; j++) {
		    var multiplier = M.elements[j][i] / M.elements[i][i];
		    els = [];
		    for (p = 0; p &#x3c; np; p++) {
			// Elements with column numbers up to an including the number
			// of the row that we&#x27;re subtracting can safely be set straight to
			// zero, since that&#x27;s the point of this routine and it avoids having
			// to loop over and correct rounding errors later
			els.push(p &#x3c;= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);
		    }
		    M.elements[j] = els;
		}
	    }
	}
	return M;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.toUpperTriangular" id="apidoc.element.sylvester.Matrix.prototype.toUpperTriangular">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>toUpperTriangular
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toUpperTriangular = function () { return this.toRightTriangular(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.tr" id="apidoc.element.sylvester.Matrix.prototype.tr">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>tr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tr = function () { return this.trace(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.trace" id="apidoc.element.sylvester.Matrix.prototype.trace">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>trace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trace = function () {
	if (!this.isSquare()) { return null; }
	var tr = this.elements[0][0], n = this.elements.length;
	for (var i = 1; i &#x3c; n; i++) {
	    tr += this.elements[i][i];
	}
	return tr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.transpose" id="apidoc.element.sylvester.Matrix.prototype.transpose">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>transpose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function () {
var rows = this.elements.length, i, cols = this.elements[0].length, j;
	var elements = [], i = cols;
	while (i--) {
	    j = rows;
	    elements[i] = [];
	    while (j--) {
		elements[i][j] = this.elements[j][i];
	    }
	}
	return Matrix.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

multiply the matrices:

    var C = A.x(B);

transpose a matrix:

    var B_T = B.<span class="apidocCodeKeywordSpan">transpose</span>();
    // B is 2x3, B_T is 3x2

= License

This project is released under The MIT License

Copyright (c) 2011, Chris Umbel, Rob Ellis, James Coglan
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.triu" id="apidoc.element.sylvester.Matrix.prototype.triu">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>triu
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">triu = function (k) {
	if(!k)
	    k = 0;
	
	return this.map(function(x, i, j) {
	    return j - i &#x3e;= k ? x : 0;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var A2 = $M([
	    [ 1, -1,  2,  2],
	    [-1,  2,  1, -1],
	    [ 2,  1,  3,  2],
	    [ 2, -1,  2,  1]
	]);

	expect(A2.<span class="apidocCodeKeywordSpan">triu</span>().eql($M([
	    [ 1, -1,  2,  2],
	    [ 0,  2,  1, -1],
	    [ 0,  0,  3,  2],
	    [ 0,  0,  0,  1]
	]))).toBeTruthy();

	expect(A2.triu(1).eql($M([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.unroll" id="apidoc.element.sylvester.Matrix.prototype.unroll">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>unroll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unroll = function () {
	var v = [];
	
	for(var i = 1; i &#x3c;= this.cols(); i++) {
	    for(var j = 1; j &#x3c;= this.rows(); j++) {
		v.push(this.e(j, i));
	    }
	}

	return $V(v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	    [ 0,  0,  1, -1],
	    [ 0,  0,  0,  2],
	    [ 0,  0,  0,  0]
	]))).toBeTruthy();
});

it(&#x27;should unroll&#x27;, function() {
	expect(A.<span class="apidocCodeKeywordSpan">unroll</span>().eql($V([1, 4, 2, 5, 3, 6]))).toBeTruthy();
});

it(&#x27;should slice&#x27;, function() {
	var A2 = $M([[1,2,3], [4,5,6], [7,8,9]]);
	var A3 = A2.slice(2, 3, 2, 3);
	expect(A3.eql($M([[5, 6], [8, 9]]))).toBeTruthy();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Matrix.prototype.x" id="apidoc.element.sylvester.Matrix.prototype.x">
        function <span class="apidocSignatureSpan">sylvester.Matrix.prototype.</span>x
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">x = function (matrix) { return this.multiply(matrix); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

add two vectors:

    var c = a.add(b);

multiply by scalar:

    var d = a.<span class="apidocCodeKeywordSpan">x</span>(2);

=== Matrices

    require(&#x27;sylvester&#x27;);

create two matrices:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Plane" id="apidoc.module.sylvester.Plane">module sylvester.Plane</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Plane.Plane" id="apidoc.element.sylvester.Plane.Plane">
        function <span class="apidocSignatureSpan">sylvester.</span>Plane
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Plane() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.create" id="apidoc.element.sylvester.Plane.create">
        function <span class="apidocSignatureSpan">sylvester.Plane.</span>create
        <span class="apidocSignatureSpan">(anchor, v1, v2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (anchor, v1, v2) {
  var P = new Plane();
  return P.setVectors(anchor, v1, v2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sylvester = require(&#x27;../lib/node-sylvester&#x27;),
Line = sylvester.Line,
LineSegment = sylvester.Line.Segment,
Vector = sylvester.Vector;

describe(&#x27;line segment&#x27;, function() {
    it(&#x27;should create&#x27;, function() {
	var lineSegment = Line.Segment.<span class="apidocCodeKeywordSpan">create</span>([1, 2], [5, 6]);
	expect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));
    })
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.fromPoints" id="apidoc.element.sylvester.Plane.fromPoints">
        function <span class="apidocSignatureSpan">sylvester.Plane.</span>fromPoints
        <span class="apidocSignatureSpan">(points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPoints = function (points) {
  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);
  for (i = 0; i &#x3c; np; i++) {
    P = Vector.create(points[i]).to3D();
    if (P === null) { return null; }
    list.push(P);
    n = list.length;
    if (n &#x3e; 2) {
      // Compute plane normal for the latest three points
      A = list[n-1].elements; B = list[n-2].elements; C = list[n-3].elements;
      N = Vector.create([
        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
      ]).toUnitVector();
      if (n &#x3e; 3) {
        // If the latest normal is not (anti)parallel to the previous one, we&#x27;ve strayed off the plane.
        // This might be a slightly long-winded way of doing things, but we need the sum of all the normals
        // to find which way the plane normal should point so that the points form an anticlockwise list.
        theta = N.angleFrom(prevN);
        if (theta !== null) {
          if (!(Math.abs(theta) &#x3c;= Sylvester.precision || Math.abs(theta - Math.PI) &#x3c;= Sylvester.precision)) { return null; }
        }
      }
      totalN = totalN.add(N);
      prevN = N;
    }
  }
  // We need to add in the normals at the start and end points, which the above misses out
  A = list[1].elements; B = list[0].elements; C = list[n-1].elements; D = list[n-2].elements;
  totalN = totalN.add(Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).toUnitVector()).add(Vector.create([
    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),
    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),
    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])
  ]).toUnitVector());
  return Plane.create(list[0], totalN);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var firstVertex = this.vertices.first.data;
  var plane = this.plane;
  this.vertices.each(function(node, i) {
    if (i &#x3c; 2) { return; }
    var points = [firstVertex, node.prev.data, node.data];
    // If the vertices lie on a straigh line, give the polygon&#x27;s own plane. If the
    // element has no area, it doesn&#x27;t matter which way its normal faces.
    triangles.push(Polygon.create(points, Plane.<span class="apidocCodeKeywordSpan">fromPoints</span>(points) || plane));
  });
  return this.setCache(&#x27;surfaceIntegralElements&#x27;, triangles);
},

// Returns the area of the polygon. Requires that the polygon
// be converted to triangles, so use with caution.
area: function() {
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Plane.prototype" id="apidoc.module.sylvester.Plane.prototype">module sylvester.Plane.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.contains" id="apidoc.element.sylvester.Plane.prototype.contains">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>contains
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (obj) {
  if (obj.normal) { return null; }
  if (obj.direction) {
    return (this.contains(obj.anchor) &#x26;&#x26; this.contains(obj.anchor.add(obj.direction)));
  } else {
    var P = obj.elements || obj;
    var A = this.anchor.elements, N = this.normal.elements;
    var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));
    return (diff &#x3c;= Sylvester.precision);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
contains: function(point) {
  return this.containsByWindingNumber(point);
},

// Returns true iff the given point is strictly inside the polygon using the winding number method
containsByWindingNumber: function(point) {
  var P = point.elements || point;
  if (!this.plane.<span class="apidocCodeKeywordSpan">contains</span>(P)) { return false; }
  if (this.hasEdgeContaining(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.distanceFrom" id="apidoc.element.sylvester.Plane.prototype.distanceFrom">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>distanceFrom
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distanceFrom = function (obj) {
  if (this.intersects(obj) || this.contains(obj)) { return 0; }
  if (obj.anchor) {
    // obj is a plane or line
    var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;
    return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);
  } else {
    // obj is a point
    var P = obj.elements || obj;
    var A = this.anchor.elements, N = this.normal.elements;
    return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.dup" id="apidoc.element.sylvester.Plane.prototype.dup">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>dup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dup = function () {
  return Plane.create(this.anchor, this.normal);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
  var poly = this.<span class="apidocCodeKeywordSpan">dup</span>(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.eql" id="apidoc.element.sylvester.Plane.prototype.eql">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>eql
        <span class="apidocSignatureSpan">(plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eql = function (plane) {
  return (this.contains(plane.anchor) &#x26;&#x26; this.isParallelTo(plane));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var svd = A.svd();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).pcaProject(1).<span class="apidocCodeKeywordSpan">eql</span>($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.pcaRecover(pca.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.intersectionWith" id="apidoc.element.sylvester.Plane.prototype.intersectionWith">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>intersectionWith
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionWith = function (obj) {
  if (!this.intersects(obj)) { return null; }
  if (obj.direction) {
    // obj is a line
    var A = obj.anchor.elements, D = obj.direction.elements,
        P = this.anchor.elements, N = this.normal.elements;
    var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);
    return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);
  } else if (obj.normal) {
    // obj is a plane
    var direction = this.normal.cross(obj.normal).toUnitVector();
    // To find an anchor point, we find one co-ordinate that has a value
    // of zero somewhere on the intersection, and remember which one we picked
    var N = this.normal.elements, A = this.anchor.elements,
        O = obj.normal.elements, B = obj.anchor.elements;
    var solver = Matrix.Zero(2,2), i = 0;
    while (solver.isSingular()) {
      i++;
      solver = Matrix.create([
        [ N[i%3], N[(i+1)%3] ],
        [ O[i%3], O[(i+1)%3]  ]
      ]);
    }
    // Then we solve the simultaneous equations in the remaining dimensions
    var inverse = solver.inverse().elements;
    var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];
    var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];
    var intersection = [
      inverse[0][0] * x + inverse[0][1] * y,
      inverse[1][0] * x + inverse[1][1] * y
    ];
    var anchor = [];
    for (var j = 1; j &#x3c;= 3; j++) {
      // This formula picks the right element from intersection by
      // cycling depending on which element we set to zero above
      anchor.push((i == j) ? 0 : intersection[(j + (5 - i)%3)%3]);
    }
    return Line.create(anchor, direction);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.intersects" id="apidoc.element.sylvester.Plane.prototype.intersects">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>intersects
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersects = function (obj) {
  if (typeof(obj.direction) == &#x27;undefined&#x27; &#x26;&#x26; typeof(obj.normal) == &#x27;undefined&#x27;) { return null; }
  return !this.isParallelTo(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.isParallelTo" id="apidoc.element.sylvester.Plane.prototype.isParallelTo">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>isParallelTo
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isParallelTo = function (obj) {
  var theta;
  if (obj.normal) {
    // obj is a plane
    theta = this.normal.angleFrom(obj.normal);
    return (Math.abs(theta) &#x3c;= Sylvester.precision || Math.abs(Math.PI - theta) &#x3c;= Sylvester.precision);
  } else if (obj.direction) {
    // obj is a line
    return this.normal.isPerpendicularTo(obj.direction);
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.cross(B).<span class="apidocCodeKeywordSpan">isParallelTo</span>(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
},

// Returns true if the given point lies on an edge of the polygon
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.isPerpendicularTo" id="apidoc.element.sylvester.Plane.prototype.isPerpendicularTo">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>isPerpendicularTo
        <span class="apidocSignatureSpan">(plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPerpendicularTo = function (plane) {
  var theta = this.normal.angleFrom(plane.normal);
  return (Math.abs(Math.PI/2 - theta) &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.pointClosestTo" id="apidoc.element.sylvester.Plane.prototype.pointClosestTo">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>pointClosestTo
        <span class="apidocSignatureSpan">(point)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pointClosestTo = function (point) {
  var P = point.elements || point;
  var A = this.anchor.elements, N = this.normal.elements;
  var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];
  return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return V.x(1/M);
  }
},

// Returns the polygon&#x27;s projection on the given plane as another polygon
projectionOn: function(plane) {
  var points = [];
  this.vertices.each(function(node) { points.push(plane.<span class="apidocCodeKeywordSpan">pointClosestTo</span>(node.data)); });
  return Polygon.create(points);
},

// Removes the given vertex from the polygon as long as it&#x27;s not triangular.
removeVertex: function(vertex) {
  if (this.isTriangle()) { return; }
  var node = this.nodeFor(vertex);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.reflectionIn" id="apidoc.element.sylvester.Plane.prototype.reflectionIn">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>reflectionIn
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reflectionIn = function (obj) {
  if (obj.normal) {
    // obj is a plane
    var A = this.anchor.elements, N = this.normal.elements;
    var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];
    var newA = this.anchor.reflectionIn(obj).elements;
    // Add the plane&#x27;s normal to its anchor, then mirror that in the other plane
    var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;
    var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;
    var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];
    return Plane.create(newA, newN);
  } else if (obj.direction) {
    // obj is a line
    return this.rotate(Math.PI, obj);
  } else {
    // obj is a point
    var P = obj.elements || obj;
    return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.rotate" id="apidoc.element.sylvester.Plane.prototype.rotate">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>rotate
        <span class="apidocSignatureSpan">(t, line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotate = function (t, line) {
  var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;
  var C = line.pointClosestTo(this.anchor).elements;
  var A = this.anchor.elements, N = this.normal.elements;
  var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];
  var x = A1 - C1, y = A2 - C2, z = A3 - C3;
  return Plane.create([
    C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,
    C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,
    C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z
  ], [
    R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],
    R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],
    R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]
  ]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
  this.vertices.each(function(node) {
    node.data.setElements(node.data.<span class="apidocCodeKeywordSpan">rotate</span>(R, line).elements);
  });
  this.plane = this.plane.rotate(R, line);
  this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });
  return this;
},

// Scales the polygon relative to the given point and returns the polygon.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.setVectors" id="apidoc.element.sylvester.Plane.prototype.setVectors">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>setVectors
        <span class="apidocSignatureSpan">(anchor, v1, v2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setVectors = function (anchor, v1, v2) {
  anchor = Vector.create(anchor);
  anchor = anchor.to3D(); if (anchor === null) { return null; }
  v1 = Vector.create(v1);
  v1 = v1.to3D(); if (v1 === null) { return null; }
  if (typeof(v2) == &#x27;undefined&#x27;) {
    v2 = null;
  } else {
    v2 = Vector.create(v2);
    v2 = v2.to3D(); if (v2 === null) { return null; }
  }
  var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];
  var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];
  var normal, mod;
  if (v2 !== null) {
    var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];
    normal = Vector.create([
      (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),
      (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),
      (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)
    ]);
    mod = normal.modulus();
    if (mod === 0) { return null; }
    normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);
  } else {
    mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);
    if (mod === 0) { return null; }
    normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);
  }
  this.anchor = anchor;
  this.normal = normal;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Plane.prototype.translate" id="apidoc.element.sylvester.Plane.prototype.translate">
        function <span class="apidocSignatureSpan">sylvester.Plane.prototype.</span>translate
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translate = function (vector) {
  var V = vector.elements || vector;
  return Plane.create([
    this.anchor.elements[0] + V[0],
    this.anchor.elements[1] + V[1],
    this.anchor.elements[2] + (V[2] || 0)
  ], this.normal);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.<span class="apidocCodeKeywordSpan">translate</span>(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Vector" id="apidoc.module.sylvester.Vector">module sylvester.Vector</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Vector.Vector" id="apidoc.element.sylvester.Vector.Vector">
        function <span class="apidocSignatureSpan">sylvester.</span>Vector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Vector() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.Fill" id="apidoc.element.sylvester.Vector.Fill">
        function <span class="apidocSignatureSpan">sylvester.Vector.</span>Fill
        <span class="apidocSignatureSpan">(n, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fill = function (n, v) {
    var elements = [];
    while (n--) { elements.push(v); }
    return Vector.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.One" id="apidoc.element.sylvester.Vector.One">
        function <span class="apidocSignatureSpan">sylvester.Vector.</span>One
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">One = function (n) {
    return Vector.Fill(n, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

returns a vector of minimum values ([1 4]):

 $M([[1, 2, 3], [5, 4, 6]]).minColumns()

create a 2x3 matrix of ones:

 var Ones = Matrix.<span class="apidocCodeKeywordSpan">One</span>(2, 3);

LU decomposition (with partial pivoting)

var lu = A.lu();
console.log(lu.L);
console.log(lu.U);
console.log(lu.P);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.Random" id="apidoc.element.sylvester.Vector.Random">
        function <span class="apidocSignatureSpan">sylvester.Vector.</span>Random
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Random = function (n) {
    var elements = [];
    while (n--) { elements.push(Math.random()); }
    return Vector.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.Zero" id="apidoc.element.sylvester.Vector.Zero">
        function <span class="apidocSignatureSpan">sylvester.Vector.</span>Zero
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Zero = function (n) {
    return Vector.Fill(n, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Returns the centroid of the polygon. Requires division into
// triangles - use with caution
centroid: function() {
  if (this.isTriangle()) {
    var A = this.v(1).elements, B = this.v(2).elements, C = this.v(3).elements;
    return Vector.create([(A[0] + B[0] + C[0])/3, (A[1] + B[1] + C[1])/3, (A[2] + B[2] + C[2])/3]);
  } else {
    var A, M = 0, V = Vector.<span class="apidocCodeKeywordSpan">Zero</span>(3), P, C, trigs = this.trianglesForSurfaceIntegral();
    var i = trigs.length;
    while (i--) {
      A = trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
      M += A;
      P = V.elements;
      C = trigs[i].centroid().elements;
      V.setElements([P[0] + C[0] * A, P[1] + C[1] * A, P[2] + C[2] * A]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.create" id="apidoc.element.sylvester.Vector.create">
        function <span class="apidocSignatureSpan">sylvester.Vector.</span>create
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (elements) {
    var V = new Vector();
    return V.setElements(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sylvester = require(&#x27;../lib/node-sylvester&#x27;),
Line = sylvester.Line,
LineSegment = sylvester.Line.Segment,
Vector = sylvester.Vector;

describe(&#x27;line segment&#x27;, function() {
    it(&#x27;should create&#x27;, function() {
	var lineSegment = Line.Segment.<span class="apidocCodeKeywordSpan">create</span>([1, 2], [5, 6]);
	expect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));
    })
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.log" id="apidoc.element.sylvester.Vector.log">
        function <span class="apidocSignatureSpan">sylvester.Vector.</span>log
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (v) {
    return v.map(function(x) {
	return Math.log(x);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
=== Vector

    require(&#x27;sylvester&#x27;);
    var a = $V([1, 2, 3]);

element-wise log:

    console.<span class="apidocCodeKeywordSpan">log</span>(a.log());

norm computation:

    console.log(a.norm());

element-wise multiplication:
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.Vector.prototype" id="apidoc.module.sylvester.Vector.prototype">module sylvester.Vector.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.add" id="apidoc.element.sylvester.Vector.prototype.add">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>add
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (value) {
	var V = value.elements || value;

	if (this.elements.length != V.length)
	    return this.map(function(v) { return v + value });
	else
	    return this.map(function(x, i) { return x + V[i - 1]; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

divide matricies:

    A.div($M([[0.5, 1], [1, 2], [2, 3]]));

scalar addition/subtraction

    A.<span class="apidocCodeKeywordSpan">add</span>(1);
    A.subtract(1);

element-wise log:

    console.log(A.log());

element-wise multiplication:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.angleFrom" id="apidoc.element.sylvester.Vector.prototype.angleFrom">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>angleFrom
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">angleFrom = function (vector) {
	var V = vector.elements || vector;
	var n = this.elements.length, k = n, i;
	if (n != V.length) { return null; }
	var dot = 0, mod1 = 0, mod2 = 0;
	// Work things out in parallel to save time
	this.each(function(x, i) {
	    dot += x * V[i - 1];
	    mod1 += x * x;
	    mod2 += V[i - 1] * V[i - 1];
	});
	mod1 = Math.sqrt(mod1); mod2 = Math.sqrt(mod2);
	if (mod1 * mod2 === 0) { return null; }
	var theta = dot / (mod1 * mod2);
	if (theta &#x3c; -1) { theta = -1; }
	if (theta &#x3e; 1) { theta = 1; }
	return Math.acos(theta);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.hasEdgeContaining(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.<span class="apidocCodeKeywordSpan">angleFrom</span>(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.cross(B).isParallelTo(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.augment" id="apidoc.element.sylvester.Vector.prototype.augment">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>augment
        <span class="apidocSignatureSpan">(elements)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augment = function (elements) {
	var newElements = this.elements;

	for (var i = 0; i &#x3c; elements.length; i++) {
	    newElements.push(elements[i]);
	}

	return Vector.create(newElements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

multiply all elements into a single scalar:

    a.product()

return a vector with the elements parameter on the bottom:

    a.<span class="apidocCodeKeywordSpan">augment</span>(elements)

=== Matrix

    var A = $M([[1, 2, 3], [4, 5, 6]]);

return subset of rows, columns:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.chomp" id="apidoc.element.sylvester.Vector.prototype.chomp">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>chomp
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chomp = function (n) {
	var elements = [];

	for (var i = n; i &#x3c; this.elements.length; i++) {
	    elements.push(this.elements[i]);
	}

	return Vector.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

element-wise division:

    a.elementDivide(vector);

remove first n nodes:

    a.<span class="apidocCodeKeywordSpan">chomp</span>(n);

return vector with first n nodes:

    a.top(n);

add all elements into a single scalar:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.cols" id="apidoc.element.sylvester.Vector.prototype.cols">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>cols
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cols = function () {
  return this.elements.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.cross" id="apidoc.element.sylvester.Vector.prototype.cross">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>cross
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cross = function (vector) {
	var B = vector.elements || vector;
	if (this.elements.length != 3 || B.length != 3) { return null; }
	var A = this.elements;
	return Vector.create([
	    (A[1] * B[2]) - (A[2] * B[1]),
	    (A[2] * B[0]) - (A[0] * B[2]),
	    (A[0] * B[1]) - (A[1] * B[0])
	]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.<span class="apidocCodeKeywordSpan">cross</span>(B).isParallelTo(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
},

// Returns true if the given point lies on an edge of the polygon
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.dimensions" id="apidoc.element.sylvester.Vector.prototype.dimensions">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>dimensions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dimensions = function () {
  return {rows: 1, cols: this.elements.length};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.distanceFrom" id="apidoc.element.sylvester.Vector.prototype.distanceFrom">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>distanceFrom
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distanceFrom = function (obj) {
	if (obj.anchor || (obj.start &#x26;&#x26; obj.end)) { return obj.distanceFrom(this); }
	var V = obj.elements || obj;
	if (V.length != this.elements.length) { return null; }
	var sum = 0, part;
	this.each(function(x, i) {
	    part = x - V[i - 1];
	    sum += part * part;
	});
	return Math.sqrt(sum);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.dot" id="apidoc.element.sylvester.Vector.prototype.dot">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>dot
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dot = function (vector) {
	var V = vector.elements || vector;
	var i, product = 0, n = this.elements.length;	
	if (n != V.length) { return null; }
	while (n--) { product += this.elements[n] * V[n]; }
	return product;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
create two vectors:

    var a = $V([1, 2, 3]);
    var b = $V([2, 3, 4]);

compute the dot product:

    var r = a.<span class="apidocCodeKeywordSpan">dot</span>(b);

add two vectors:

    var c = a.add(b);

multiply by scalar:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.dup" id="apidoc.element.sylvester.Vector.prototype.dup">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>dup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dup = function () {
	    return Vector.create(this.elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
  var poly = this.<span class="apidocCodeKeywordSpan">dup</span>(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.e" id="apidoc.element.sylvester.Vector.prototype.e">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>e
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">e = function (i) {
  return (i &#x3c; 1 || i &#x3e; this.elements.length) ? null : this.elements[i - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.each" id="apidoc.element.sylvester.Vector.prototype.each">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>each
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (fn) {
	var n = this.elements.length;
	for (var i = 0; i &#x3c; n; i++) {
	    fn(this.elements[i], i + 1);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dup: function() {
  return Polygon.create(this.vertices, this.plane);
},

// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.<span class="apidocCodeKeywordSpan">each</span>(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.translate(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.elementDivide" id="apidoc.element.sylvester.Vector.prototype.elementDivide">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>elementDivide
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elementDivide = function (vector) {
	return this.map(function(v, i) {
	    return v / vector.e(i);
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

element-wise multiplication:

    a.elementMultiply(vector);

element-wise division:

    a.<span class="apidocCodeKeywordSpan">elementDivide</span>(vector);

remove first n nodes:

    a.chomp(n);

return vector with first n nodes:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.elementMultiply" id="apidoc.element.sylvester.Vector.prototype.elementMultiply">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>elementMultiply
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elementMultiply = function (v) {
	return this.map(function(k, i) {
	    return v.e(i) * k;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

norm computation:

    console.log(a.norm());

element-wise multiplication:

    a.<span class="apidocCodeKeywordSpan">elementMultiply</span>(vector);

element-wise division:

    a.elementDivide(vector);

remove first n nodes:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.eql" id="apidoc.element.sylvester.Vector.prototype.eql">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>eql
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eql = function (vector) {
	var n = this.elements.length;
	var V = vector.elements || vector;
	if (n != V.length) { return false; }
	while (n--) {
	    if (Math.abs(this.elements[n] - V[n]) &#x3e; Sylvester.precision) { return false; }
	}
	return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var svd = A.svd();
console.log(svd.U);
console.log(svd.S);
console.log(svd.V);

PCA

var A = $M([[1, 2], [5, 7]]).pcaProject(1).<span class="apidocCodeKeywordSpan">eql</span>($M([
            [-2.2120098720461616],
            [-8.601913944732665]
        ]);
var pca = A.pcaProject(1);
var Z = pca.Z;
var A = Z.pcaRecover(pca.U);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.indexOf" id="apidoc.element.sylvester.Vector.prototype.indexOf">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (x) {
	var index = null, n = this.elements.length;
	for (var i = 0; i &#x3c; n; i++) {
	    if (index === null &#x26;&#x26; this.elements[i] == x) {
		index = i + 1;
	    }
	}
	return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.inspect" id="apidoc.element.sylvester.Vector.prototype.inspect">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
	return &#x27;[&#x27; + this.elements.join(&#x27;, &#x27;) + &#x27;]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.cached[key] = value;
  return value;
},

// Returns a string representation of the polygon&#x27;s vertices.
inspect: function() {
  var points = [];
  this.vertices.each(function(node) { points.push(node.data.<span class="apidocCodeKeywordSpan">inspect</span>()); });
  return points.join(&#x27; -&#x3e; &#x27;);
}
};

// Constructor function
Polygon.create = function(points, plane) {
var P = new Polygon();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.isAntiparallelTo" id="apidoc.element.sylvester.Vector.prototype.isAntiparallelTo">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>isAntiparallelTo
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAntiparallelTo = function (vector) {
	var angle = this.angleFrom(vector);
	return (angle === null) ? null : (Math.abs(angle - Math.PI) &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.isParallelTo" id="apidoc.element.sylvester.Vector.prototype.isParallelTo">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>isParallelTo
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isParallelTo = function (vector) {
	var angle = this.angleFrom(vector);
	return (angle === null) ? null : (angle &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.cross(B).<span class="apidocCodeKeywordSpan">isParallelTo</span>(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
},

// Returns true if the given point lies on an edge of the polygon
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.isPerpendicularTo" id="apidoc.element.sylvester.Vector.prototype.isPerpendicularTo">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>isPerpendicularTo
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPerpendicularTo = function (vector) {
	var dot = this.dot(vector);
	return (dot === null) ? null : (Math.abs(dot) &#x3c;= Sylvester.precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.liesIn" id="apidoc.element.sylvester.Vector.prototype.liesIn">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>liesIn
        <span class="apidocSignatureSpan">(plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">liesIn = function (plane) {
	return plane.contains(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.liesOn" id="apidoc.element.sylvester.Vector.prototype.liesOn">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>liesOn
        <span class="apidocSignatureSpan">(line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">liesOn = function (line) {
	return line.contains(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.log" id="apidoc.element.sylvester.Vector.prototype.log">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
	return Vector.log(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
=== Vector

    require(&#x27;sylvester&#x27;);
    var a = $V([1, 2, 3]);

element-wise log:

    console.<span class="apidocCodeKeywordSpan">log</span>(a.log());

norm computation:

    console.log(a.norm());

element-wise multiplication:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.map" id="apidoc.element.sylvester.Vector.prototype.map">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>map
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (fn) {
	var elements = [];
	this.each(function(x, i) {
	    elements.push(fn(x, i));
	});
	return Vector.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.max" id="apidoc.element.sylvester.Vector.prototype.max">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function () {
	var m = 0, i = this.elements.length;
	while (i--) {
	    if (Math.abs(this.elements[i]) &#x3e; Math.abs(m)) { m = this.elements[i]; }
	}
	return m;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.maxIndex" id="apidoc.element.sylvester.Vector.prototype.maxIndex">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>maxIndex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxIndex = function () {
	var m = 0, i = this.elements.length;
	var maxIndex = -1;

	while (i--) {
	    if (Math.abs(this.elements[i]) &#x3e; Math.abs(m)) {
		m = this.elements[i];
		maxIndex = i + 1;
	    }
	}

	return maxIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.modulus" id="apidoc.element.sylvester.Vector.prototype.modulus">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>modulus
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modulus = function () {
  return Math.sqrt(this.dot(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Area is half the modulus of the cross product of two sides
  var A = this.vertices.first, B = A.next, C = B.next;
  A = A.data.elements; B = B.data.elements; C = C.data.elements;
  return 0.5 * Vector.create([
    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
  ]).<span class="apidocCodeKeywordSpan">modulus</span>();
} else {
  var trigs = this.trianglesForSurfaceIntegral(), area = 0;
  var i = trigs.length;
  while (i--) {
    area += trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
  }
  return area;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.multiply" id="apidoc.element.sylvester.Vector.prototype.multiply">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>multiply
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiply = function (k) {
	return this.map(function(x) { return x * k; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.norm" id="apidoc.element.sylvester.Vector.prototype.norm">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>norm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">norm = function () {
	var n = this.elements.length;
	var sum = 0;

	while (n--) {
	    sum += Math.pow(this.elements[n], 2);
	}

	return Math.sqrt(sum);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

element-wise log:

    console.log(a.log());

norm computation:

    console.log(a.<span class="apidocCodeKeywordSpan">norm</span>());

element-wise multiplication:

    a.elementMultiply(vector);

element-wise division:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.product" id="apidoc.element.sylvester.Vector.prototype.product">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>product
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">product = function () {
	var p = 1;

	this.map(function(v) {
	    p *= v;
	});

	return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

add all elements into a single scalar:

    a.sum()

multiply all elements into a single scalar:

    a.<span class="apidocCodeKeywordSpan">product</span>()

return a vector with the elements parameter on the bottom:

    a.augment(elements)

=== Matrix
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.reflectionIn" id="apidoc.element.sylvester.Vector.prototype.reflectionIn">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>reflectionIn
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reflectionIn = function (obj) {
	if (obj.anchor) {
	    // obj is a plane or line
	    var P = this.elements.slice();
	    var C = obj.pointClosestTo(P).elements;
	    return Vector.create([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);
	} else {
	    // obj is a point
	    var Q = obj.elements || obj;
	    if (this.elements.length != Q.length) { return null; }
	    return this.map(function(x, i) { return Q[i - 1] + (Q[i - 1] - x); });
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.rotate" id="apidoc.element.sylvester.Vector.prototype.rotate">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>rotate
        <span class="apidocSignatureSpan">(t, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotate = function (t, obj) {
	var V, R = null, x, y, z;
	if (t.determinant) { R = t.elements; }
	switch (this.elements.length) {
	case 2:
        V = obj.elements || obj;
        if (V.length != 2) { return null; }
        if (!R) { R = Matrix.Rotation(t).elements; }
        x = this.elements[0] - V[0];
        y = this.elements[1] - V[1];
        return Vector.create([
		V[0] + R[0][0] * x + R[0][1] * y,
		V[1] + R[1][0] * x + R[1][1] * y
        ]);
        break;
	case 3:
        if (!obj.direction) { return null; }
        var C = obj.pointClosestTo(this).elements;
        if (!R) { R = Matrix.Rotation(t, obj.direction).elements; }
        x = this.elements[0] - C[0];
        y = this.elements[1] - C[1];
        z = this.elements[2] - C[2];
        return Vector.create([
		C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,
		C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,
		C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z
        ]);
        break;
	default:
        return null;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
  this.vertices.each(function(node) {
    node.data.setElements(node.data.<span class="apidocCodeKeywordSpan">rotate</span>(R, line).elements);
  });
  this.plane = this.plane.rotate(R, line);
  this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });
  return this;
},

// Scales the polygon relative to the given point and returns the polygon.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.round" id="apidoc.element.sylvester.Vector.prototype.round">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
	return this.map(function(x) { return Math.round(x); });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.rows" id="apidoc.element.sylvester.Vector.prototype.rows">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>rows
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rows = function () {
  return 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.setElements" id="apidoc.element.sylvester.Vector.prototype.setElements">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>setElements
        <span class="apidocSignatureSpan">(els)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setElements = function (els) {
	this.elements = (els.elements || els).slice();
	return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.<span class="apidocCodeKeywordSpan">setElements</span>([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.translate(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.snapTo" id="apidoc.element.sylvester.Vector.prototype.snapTo">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>snapTo
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">snapTo = function (x) {
	return this.map(function(y) {
	    return (Math.abs(y - x) &#x3c;= Sylvester.precision) ? x : y;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var A = $M([[1, 2, 3], [4, 5, 6]]);
	var B = $M([[1, 2, 3], [4, 5, 7]]);

	expect(A.eql(B)).toBeFalsy();
});

it(&#x27;should snap&#x27;, function() {
	expect($M([[1, 1.1, 1.00000001], [4, 5, 6]]).<span class="apidocCodeKeywordSpan">snapTo</span>(1).eql(
	    $M([[1, 1.1, 1], [4, 5, 6]]))).toBeTruthy();
});

it(&#x27;should compute the minimum index of matrix rows&#x27;, function() {
	expect($M([[1, 2, 3], [2, 1, 3], [2, 1, 0]]).minColumnIndexes().eql($V([2, 1, 3])));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.subtract" id="apidoc.element.sylvester.Vector.prototype.subtract">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>subtract
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function (v) {
	if (typeof(v) == &#x27;number&#x27;)
	    return this.map(function(k) { return k - v; });

	var V = v.elements || v;
	if (this.elements.length != V.length) { return null; }
	return this.map(function(x, i) { return x - V[i - 1]; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
divide matricies:

    A.div($M([[0.5, 1], [1, 2], [2, 3]]));

scalar addition/subtraction

    A.add(1);
    A.<span class="apidocCodeKeywordSpan">subtract</span>(1);

element-wise log:

    console.log(A.log());

element-wise multiplication:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.sum" id="apidoc.element.sylvester.Vector.prototype.sum">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>sum
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function () {
	var sum = 0;
	this.map(function(x) { sum += x;});
	return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return vector with first n nodes:

    a.top(n);

add all elements into a single scalar:

    a.<span class="apidocCodeKeywordSpan">sum</span>()

multiply all elements into a single scalar:

    a.product()

return a vector with the elements parameter on the bottom:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.to3D" id="apidoc.element.sylvester.Vector.prototype.to3D">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>to3D
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">to3D = function () {
	var V = this.dup();
	switch (V.elements.length) {
	case 3: break;
	case 2: V.elements.push(0); break;
	default: return null;
	}
	return V;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.toDiagonalMatrix" id="apidoc.element.sylvester.Vector.prototype.toDiagonalMatrix">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>toDiagonalMatrix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDiagonalMatrix = function () {
	return Matrix.Diagonal(this.elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.toUnitVector" id="apidoc.element.sylvester.Vector.prototype.toUnitVector">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>toUnitVector
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toUnitVector = function () {
	var r = this.modulus();
	if (r === 0) { return this.dup(); }
	return this.map(function(x) { return x / r; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.top" id="apidoc.element.sylvester.Vector.prototype.top">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>top
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">top = function (n) {
	var elements = [];

	for (var i = 0; i &#x3c; n; i++) {
	    elements.push(this.elements[i]);
	}

	return Vector.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

remove first n nodes:

    a.chomp(n);

return vector with first n nodes:

    a.<span class="apidocCodeKeywordSpan">top</span>(n);

add all elements into a single scalar:

    a.sum()

multiply all elements into a single scalar:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.transpose" id="apidoc.element.sylvester.Vector.prototype.transpose">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>transpose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transpose = function () {
	var rows = this.elements.length;
	var elements = [];

	for (var i = 0; i &#x3c; rows; i++) {
	    elements.push([this.elements[i]]);
	}
	return Matrix.create(elements);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

multiply the matrices:

    var C = A.x(B);

transpose a matrix:

    var B_T = B.<span class="apidocCodeKeywordSpan">transpose</span>();
    // B is 2x3, B_T is 3x2

= License

This project is released under The MIT License

Copyright (c) 2011, Chris Umbel, Rob Ellis, James Coglan
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.Vector.prototype.x" id="apidoc.element.sylvester.Vector.prototype.x">
        function <span class="apidocSignatureSpan">sylvester.Vector.prototype.</span>x
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">x = function (k) { return this.multiply(k); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

add two vectors:

    var c = a.add(b);

multiply by scalar:

    var d = a.<span class="apidocCodeKeywordSpan">x</span>(2);

=== Matrices

    require(&#x27;sylvester&#x27;);

create two matrices:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.linkedlist" id="apidoc.module.sylvester.linkedlist">module sylvester.linkedlist</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.linkedlist" id="apidoc.element.sylvester.linkedlist.linkedlist">
        function <span class="apidocSignatureSpan">sylvester.</span>linkedlist
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LinkedList() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.Circular" id="apidoc.element.sylvester.linkedlist.Circular">
        function <span class="apidocSignatureSpan">sylvester.linkedlist.</span>Circular
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Circular = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

LinkedList.Circular.prototype = new LinkedList;
for (var method in LinkedList.Circular.Methods) {
  LinkedList.Circular.prototype[method] = LinkedList.Circular.Methods[method];
}

LinkedList.Circular.fromArray = function(list, useNodes) {
  var linked = new LinkedList.<span class="apidocCodeKeywordSpan">Circular</span>();
  var n = list.length;
  while (n--) { linked.prepend(useNodes ? new LinkedList.Node(list[n]) : list[n]); }
  return linked;
};

module.exports = LinkedList;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.Node" id="apidoc.element.sylvester.linkedlist.Node">
        function <span class="apidocSignatureSpan">sylvester.linkedlist.</span>Node
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Node = function (data) {
  this.prev = null; this.next = null;
  this.data = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var method in LinkedList.Circular.Methods) {
  LinkedList.Circular.prototype[method] = LinkedList.Circular.Methods[method];
}

LinkedList.Circular.fromArray = function(list, useNodes) {
  var linked = new LinkedList.Circular();
  var n = list.length;
  while (n--) { linked.prepend(useNodes ? new LinkedList.<span class="apidocCodeKeywordSpan">Node</span>(list[n]) : list[n]); }
  return linked;
};

module.exports = LinkedList;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.linkedlist.prototype" id="apidoc.module.sylvester.linkedlist.prototype">module sylvester.linkedlist.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.prototype.at" id="apidoc.element.sylvester.linkedlist.prototype.at">
        function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>at
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">at = function (i) {
  if (!(i &#x3e;= 0 &#x26;&#x26; i &#x3c; this.length)) { return null; }
  var node = this.first;
  while (i--) { node = node.next; }
  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var node = this.first;
  while (i--) { node = node.next; }
  return node;
},

randomNode: function() {
  var n = Math.floor(Math.random() * this.length);
  return this.<span class="apidocCodeKeywordSpan">at</span>(n);
},

toArray: function() {
  var arr = [], node = this.first, n = this.length;
  while (n--) {
    arr.push(node.data || node);
    node = node.next;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.prototype.each" id="apidoc.element.sylvester.linkedlist.prototype.each">
        function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>each
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (fn) {
  var node = this.first, n = this.length;
  for (var i = 0; i &#x3c; n; i++) {
    fn(node, i);
    node = node.next;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dup: function() {
  return Polygon.create(this.vertices, this.plane);
},

// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.<span class="apidocCodeKeywordSpan">each</span>(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.translate(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.prototype.randomNode" id="apidoc.element.sylvester.linkedlist.prototype.randomNode">
        function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>randomNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randomNode = function () {
  var n = Math.floor(Math.random() * this.length);
  return this.at(n);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  triangulateByEarClipping: function() {
var poly = this.dup(), triangles = [], success, convexNode, mainNode, trig;
while (!poly.isTriangle()) {
  success = false;
  while (!success) {
    success = true;
    // Ear tips must be convex vertices - let&#x27;s pick one at random
    convexNode = poly.convexVertices.<span class="apidocCodeKeywordSpan">randomNode</span>();
    mainNode = poly.vertices.withData(convexNode.data);
    // For convex vertices, this order will always be anticlockwise
    trig = Polygon.create([mainNode.data, mainNode.next.data, mainNode.prev.data], this.plane);
    // Now test whether any reflex vertices lie within the ear
    poly.reflexVertices.each(function(node) {
      // Don&#x27;t test points belonging to this triangle. node won&#x27;t be
      // equal to convexNode as node is reflex and vertex is convex.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.linkedlist.prototype.toArray" id="apidoc.element.sylvester.linkedlist.prototype.toArray">
        function <span class="apidocSignatureSpan">sylvester.linkedlist.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  var arr = [], node = this.first, n = this.length;
  while (n--) {
    arr.push(node.data || node);
    node = node.next;
  }
  return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Need to do this to renumber the remaining vertices
  triangles.push(Polygon.create(poly.vertices, this.plane));
  return triangles;
},

// Sets the polygon&#x27;s vertices
setVertices: function(points, plane) {
  var pointSet = points.toArray ? points.<span class="apidocCodeKeywordSpan">toArray</span>() : points;
  this.plane = (plane &#x26;&#x26; plane.normal) ? plane.dup() : Plane.fromPoints(pointSet);
  if (this.plane === null) { return null; }
  this.vertices = new LinkedList.Circular();
  // Construct linked list of vertices. If each point is already a polygon
  // vertex, we reference it rather than creating a new vertex.
  var i = pointSet.length, newVertex;
  while (i--) {
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.polygon" id="apidoc.module.sylvester.polygon">module sylvester.polygon</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.polygon.polygon" id="apidoc.element.sylvester.polygon.polygon">
        function <span class="apidocSignatureSpan">sylvester.</span>polygon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Polygon() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.create" id="apidoc.element.sylvester.polygon.create">
        function <span class="apidocSignatureSpan">sylvester.polygon.</span>create
        <span class="apidocSignatureSpan">(points, plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (points, plane) {
  var P = new Polygon();
  return P.setVertices(points, plane);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var sylvester = require(&#x27;../lib/node-sylvester&#x27;),
Line = sylvester.Line,
LineSegment = sylvester.Line.Segment,
Vector = sylvester.Vector;

describe(&#x27;line segment&#x27;, function() {
    it(&#x27;should create&#x27;, function() {
	var lineSegment = Line.Segment.<span class="apidocCodeKeywordSpan">create</span>([1, 2], [5, 6]);
	expect(lineSegment.line.anchor).toEqual(Vector.create([1, 2, 0]));
    })
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sylvester.polygon.prototype" id="apidoc.module.sylvester.polygon.prototype">module sylvester.polygon.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.area" id="apidoc.element.sylvester.polygon.prototype.area">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>area
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">area = function () {
  if (this.isTriangle()) {
    // Area is half the modulus of the cross product of two sides
    var A = this.vertices.first, B = A.next, C = B.next;
    A = A.data.elements; B = B.data.elements; C = C.data.elements;
    return 0.5 * Vector.create([
      (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
      (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
      (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
    ]).modulus();
  } else {
    var trigs = this.trianglesForSurfaceIntegral(), area = 0;
    var i = trigs.length;
    while (i--) {
      area += trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
    }
    return area;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
      (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
    ]).modulus();
  } else {
    var trigs = this.trianglesForSurfaceIntegral(), area = 0;
    var i = trigs.length;
    while (i--) {
      area += trigs[i].<span class="apidocCodeKeywordSpan">area</span>() * trigs[i].plane.normal.dot(this.plane.normal);
    }
    return area;
  }
},

// Returns the centroid of the polygon. Requires division into
// triangles - use with caution
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.centroid" id="apidoc.element.sylvester.polygon.prototype.centroid">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>centroid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">centroid = function () {
  if (this.isTriangle()) {
    var A = this.v(1).elements, B = this.v(2).elements, C = this.v(3).elements;
    return Vector.create([(A[0] + B[0] + C[0])/3, (A[1] + B[1] + C[1])/3, (A[2] + B[2] + C[2])/3]);
  } else {
    var A, M = 0, V = Vector.Zero(3), P, C, trigs = this.trianglesForSurfaceIntegral();
    var i = trigs.length;
    while (i--) {
      A = trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
      M += A;
      P = V.elements;
      C = trigs[i].centroid().elements;
      V.setElements([P[0] + C[0] * A, P[1] + C[1] * A, P[2] + C[2] * A]);
    }
    return V.x(1/M);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    var A, M = 0, V = Vector.Zero(3), P, C, trigs = this.trianglesForSurfaceIntegral();
    var i = trigs.length;
    while (i--) {
      A = trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
      M += A;
      P = V.elements;
      C = trigs[i].<span class="apidocCodeKeywordSpan">centroid</span>().elements;
      V.setElements([P[0] + C[0] * A, P[1] + C[1] * A, P[2] + C[2] * A]);
    }
    return V.x(1/M);
  }
},

// Returns the polygon&#x27;s projection on the given plane as another polygon
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.clearCache" id="apidoc.element.sylvester.polygon.prototype.clearCache">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCache = function () {
  this.cached = {
    triangles: null,
    surfaceIntegralElements: null
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Removes the given vertex from the polygon as long as it&#x27;s not triangular.
removeVertex: function(vertex) {
  if (this.isTriangle()) { return; }
  var node = this.nodeFor(vertex);
  if (node === null) { return null; }
  this.<span class="apidocCodeKeywordSpan">clearCache</span>();
  // Previous and next entries in the main vertex list
  var prev = node.prev, next = node.next;
  var prevWasConvex = prev.data.isConvex(this);
  var nextWasConvex = next.data.isConvex(this);
  if (node.data.isConvex(this)) {
    this.convexVertices.remove(this.convexVertices.withData(node.data));
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.contains" id="apidoc.element.sylvester.polygon.prototype.contains">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>contains
        <span class="apidocSignatureSpan">(point)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (point) {
  return this.containsByWindingNumber(point);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
contains: function(point) {
  return this.containsByWindingNumber(point);
},

// Returns true iff the given point is strictly inside the polygon using the winding number method
containsByWindingNumber: function(point) {
  var P = point.elements || point;
  if (!this.plane.<span class="apidocCodeKeywordSpan">contains</span>(P)) { return false; }
  if (this.hasEdgeContaining(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.containsByWindingNumber" id="apidoc.element.sylvester.polygon.prototype.containsByWindingNumber">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>containsByWindingNumber
        <span class="apidocSignatureSpan">(point)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">containsByWindingNumber = function (point) {
  var P = point.elements || point;
  if (!this.plane.contains(P)) { return false; }
  if (this.hasEdgeContaining(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
    if (dt === null || dt === 0) { return; }
    theta += (A.cross(B).isParallelTo(self.plane.normal) ? 1 : -1) * dt;
    if (theta &#x3e;= 2 * Math.PI - Sylvester.precision) { loops++; theta -= 2 * Math.PI; }
    if (theta &#x3c;= -2 * Math.PI + Sylvester.precision) { loops--; theta += 2 * Math.PI; }
  });
  return loops != 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  return this;
},

// Returns true iff the point is strictly inside the polygon
contains: function(point) {
  return this.<span class="apidocCodeKeywordSpan">containsByWindingNumber</span>(point);
},

// Returns true iff the given point is strictly inside the polygon using the winding number method
containsByWindingNumber: function(point) {
  var P = point.elements || point;
  if (!this.plane.contains(P)) { return false; }
  if (this.hasEdgeContaining(P)) { return false; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.copyVertices" id="apidoc.element.sylvester.polygon.prototype.copyVertices">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>copyVertices
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyVertices = function () {
  this.clearCache();
  this.vertices.each(function(node) {
    node.data = new Polygon.Vertex(node.data);
  });
  this.populateVertexTypeLists();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.dup" id="apidoc.element.sylvester.polygon.prototype.dup">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>dup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dup = function () {
  return Polygon.create(this.vertices, this.plane);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
  var poly = this.<span class="apidocCodeKeywordSpan">dup</span>(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.hasEdgeContaining" id="apidoc.element.sylvester.polygon.prototype.hasEdgeContaining">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>hasEdgeContaining
        <span class="apidocSignatureSpan">(point)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasEdgeContaining = function (point) {
  var P = (point.elements || point);
  var success = false;
  this.vertices.each(function(node) {
    if (Line.Segment.create(node.data, node.next.data).contains(P)) { success = true; }
  });
  return success;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.containsByWindingNumber(point);
},

// Returns true iff the given point is strictly inside the polygon using the winding number method
containsByWindingNumber: function(point) {
  var P = point.elements || point;
  if (!this.plane.contains(P)) { return false; }
  if (this.<span class="apidocCodeKeywordSpan">hasEdgeContaining</span>(P)) { return false; }
  var V, W, A, B, theta = 0, dt, loops = 0, self = this;
  this.vertices.each(function(node) {
    V = node.data.elements;
    W = node.next.data.elements;
    A = Vector.create([V[0] - P[0], V[1] - P[1], V[2] - (P[2] || 0)]);
    B = Vector.create([W[0] - P[0], W[1] - P[1], W[2] - (P[2] || 0)]);
    dt = A.angleFrom(B);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.inspect" id="apidoc.element.sylvester.polygon.prototype.inspect">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  var points = [];
  this.vertices.each(function(node) { points.push(node.data.inspect()); });
  return points.join(&#x27; -&#x3e; &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.cached[key] = value;
  return value;
},

// Returns a string representation of the polygon&#x27;s vertices.
inspect: function() {
  var points = [];
  this.vertices.each(function(node) { points.push(node.data.<span class="apidocCodeKeywordSpan">inspect</span>()); });
  return points.join(&#x27; -&#x3e; &#x27;);
}
};

// Constructor function
Polygon.create = function(points, plane) {
var P = new Polygon();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.isTriangle" id="apidoc.element.sylvester.polygon.prototype.isTriangle">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>isTriangle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTriangle = function () {
  return this.vertices.length == 3;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  return this.setCache(&#x27;surfaceIntegralElements&#x27;, triangles);
},

// Returns the area of the polygon. Requires that the polygon
// be converted to triangles, so use with caution.
area: function() {
  if (this.<span class="apidocCodeKeywordSpan">isTriangle</span>()) {
    // Area is half the modulus of the cross product of two sides
    var A = this.vertices.first, B = A.next, C = B.next;
    A = A.data.elements; B = B.data.elements; C = C.data.elements;
    return 0.5 * Vector.create([
      (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
      (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
      (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.nodeFor" id="apidoc.element.sylvester.polygon.prototype.nodeFor">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>nodeFor
        <span class="apidocSignatureSpan">(vertex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodeFor = function (vertex) {
  return this.vertices.withData(vertex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node) { points.push(plane.pointClosestTo(node.data)); });
  return Polygon.create(points);
},

// Removes the given vertex from the polygon as long as it&#x27;s not triangular.
removeVertex: function(vertex) {
  if (this.isTriangle()) { return; }
  var node = this.<span class="apidocCodeKeywordSpan">nodeFor</span>(vertex);
  if (node === null) { return null; }
  this.clearCache();
  // Previous and next entries in the main vertex list
  var prev = node.prev, next = node.next;
  var prevWasConvex = prev.data.isConvex(this);
  var nextWasConvex = next.data.isConvex(this);
  if (node.data.isConvex(this)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.populateVertexTypeLists" id="apidoc.element.sylvester.polygon.prototype.populateVertexTypeLists">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>populateVertexTypeLists
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">populateVertexTypeLists = function () {
  this.convexVertices = new LinkedList.Circular();
  this.reflexVertices = new LinkedList.Circular();
  var self = this;
  this.vertices.each(function(node) {
    // Split vertices into convex / reflex groups
    // The LinkedList.Node class wraps each vertex so it can belong to many linked lists.
    self[node.data.type(self) + &#x27;Vertices&#x27;].append(new LinkedList.Node(node.data));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // vertex, we reference it rather than creating a new vertex.
  var i = pointSet.length, newVertex;
  while (i--) {
    newVertex = pointSet[i].isConvex ? pointSet[i] : new Polygon.Vertex(pointSet[i]);
    this.vertices.prepend(new LinkedList.Node(newVertex));
  }
  this.clearCache();
  this.<span class="apidocCodeKeywordSpan">populateVertexTypeLists</span>();
  return this;
},

// Constructs lists of convex and reflex vertices based on the main vertex list.
populateVertexTypeLists: function() {
  this.convexVertices = new LinkedList.Circular();
  this.reflexVertices = new LinkedList.Circular();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.projectionOn" id="apidoc.element.sylvester.polygon.prototype.projectionOn">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>projectionOn
        <span class="apidocSignatureSpan">(plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">projectionOn = function (plane) {
  var points = [];
  this.vertices.each(function(node) { points.push(plane.pointClosestTo(node.data)); });
  return Polygon.create(points);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.removeVertex" id="apidoc.element.sylvester.polygon.prototype.removeVertex">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>removeVertex
        <span class="apidocSignatureSpan">(vertex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeVertex = function (vertex) {
  if (this.isTriangle()) { return; }
  var node = this.nodeFor(vertex);
  if (node === null) { return null; }
  this.clearCache();
  // Previous and next entries in the main vertex list
  var prev = node.prev, next = node.next;
  var prevWasConvex = prev.data.isConvex(this);
  var nextWasConvex = next.data.isConvex(this);
  if (node.data.isConvex(this)) {
    this.convexVertices.remove(this.convexVertices.withData(node.data));
  } else {
    this.reflexVertices.remove(this.reflexVertices.withData(node.data));
  }
  this.vertices.remove(node);
  // Deal with previous vertex&#x27;s change of class
  if (prevWasConvex != prev.data.isConvex(this)) {
    if (prevWasConvex) {
      this.convexVertices.remove(this.convexVertices.withData(prev.data));
      this.reflexVertices.append(new LinkedList.Node(prev.data));
    } else {
      this.reflexVertices.remove(this.reflexVertices.withData(prev.data));
      this.convexVertices.append(new LinkedList.Node(prev.data));
    }
  }
  // Deal with next vertex&#x27;s change of class
  if (nextWasConvex != next.data.isConvex(this)) {
    if (nextWasConvex) {
      this.convexVertices.remove(this.convexVertices.withData(next.data));
      this.reflexVertices.append(new LinkedList.Node(next.data));
    } else {
      this.reflexVertices.remove(this.reflexVertices.withData(next.data));
      this.convexVertices.append(new LinkedList.Node(next.data));
    }
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // equal to convexNode as node is reflex and vertex is convex.
        if (node.data != mainNode.prev.data &#x26;&#x26; node.data != mainNode.next.data) {
          if (trig.contains(node.data) || trig.hasEdgeContaining(node.data)) { success = false; }
        }
      });
    }
    triangles.push(trig);
    poly.<span class="apidocCodeKeywordSpan">removeVertex</span>(mainNode.data);
  }
  // Need to do this to renumber the remaining vertices
  triangles.push(Polygon.create(poly.vertices, this.plane));
  return triangles;
},

// Sets the polygon&#x27;s vertices
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.rotate" id="apidoc.element.sylvester.polygon.prototype.rotate">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>rotate
        <span class="apidocSignatureSpan">(t, line)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotate = function (t, line) {
  var R = Matrix.Rotation(t, line.direction);
  this.vertices.each(function(node) {
    node.data.setElements(node.data.rotate(R, line).elements);
  });
  this.plane = this.plane.rotate(R, line);
  this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
  this.vertices.each(function(node) {
    node.data.setElements(node.data.<span class="apidocCodeKeywordSpan">rotate</span>(R, line).elements);
  });
  this.plane = this.plane.rotate(R, line);
  this.updateTrianglePlanes(function(plane) { return plane.rotate(R, line); });
  return this;
},

// Scales the polygon relative to the given point and returns the polygon.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.scale" id="apidoc.element.sylvester.polygon.prototype.scale">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>scale
        <span class="apidocSignatureSpan">(k, point)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scale = function (k, point) {
  var P = point.elements || point;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([
      P[0] + k * (E[0] - P[0]),
      P[1] + k * (E[1] - P[1]),
      (P[2] || 0) + k * (E[2] - (P[2] || 0))
    ]);
  });
  var anchor = this.vertices.first.data;
  this.plane.anchor.setElements(anchor);
  this.updateTrianglePlanes(function(plane) { return Plane.create(anchor, plane.normal); });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.setCache" id="apidoc.element.sylvester.polygon.prototype.setCache">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>setCache
        <span class="apidocSignatureSpan">(key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCache = function (key, value) {
  this.cached[key] = value;
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.vertices.each(function(node, i) {
    if (i &#x3c; 2) { return; }
    var points = [firstVertex, node.prev.data, node.data];
    // If the vertices lie on a straigh line, give the polygon&#x27;s own plane. If the
    // element has no area, it doesn&#x27;t matter which way its normal faces.
    triangles.push(Polygon.create(points, Plane.fromPoints(points) || plane));
  });
  return this.<span class="apidocCodeKeywordSpan">setCache</span>(&#x27;surfaceIntegralElements&#x27;, triangles);
},

// Returns the area of the polygon. Requires that the polygon
// be converted to triangles, so use with caution.
area: function() {
  if (this.isTriangle()) {
    // Area is half the modulus of the cross product of two sides
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.setVertices" id="apidoc.element.sylvester.polygon.prototype.setVertices">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>setVertices
        <span class="apidocSignatureSpan">(points, plane)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setVertices = function (points, plane) {
  var pointSet = points.toArray ? points.toArray() : points;
  this.plane = (plane &#x26;&#x26; plane.normal) ? plane.dup() : Plane.fromPoints(pointSet);
  if (this.plane === null) { return null; }
  this.vertices = new LinkedList.Circular();
  // Construct linked list of vertices. If each point is already a polygon
  // vertex, we reference it rather than creating a new vertex.
  var i = pointSet.length, newVertex;
  while (i--) {
    newVertex = pointSet[i].isConvex ? pointSet[i] : new Polygon.Vertex(pointSet[i]);
    this.vertices.prepend(new LinkedList.Node(newVertex));
  }
  this.clearCache();
  this.populateVertexTypeLists();
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return points.join(&#x27; -&#x3e; &#x27;);
  }
};

// Constructor function
Polygon.create = function(points, plane) {
  var P = new Polygon();
  return P.<span class="apidocCodeKeywordSpan">setVertices</span>(points, plane);
};

module.exports = Polygon;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.toTriangles" id="apidoc.element.sylvester.polygon.prototype.toTriangles">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>toTriangles
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toTriangles = function () {
  if (this.cached.triangles !== null) { return this.cached.triangles; }
  return this.setCache(&#x27;triangles&#x27;, this.triangulateByEarClipping());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.translate" id="apidoc.element.sylvester.polygon.prototype.translate">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>translate
        <span class="apidocSignatureSpan">(vector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translate = function (vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.translate(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Translates the polygon by the given vector and returns the polygon.
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.<span class="apidocCodeKeywordSpan">translate</span>(vector);
  this.updateTrianglePlanes(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.trianglesForSurfaceIntegral" id="apidoc.element.sylvester.polygon.prototype.trianglesForSurfaceIntegral">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>trianglesForSurfaceIntegral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trianglesForSurfaceIntegral = function () {
  if (this.cached.surfaceIntegralElements !== null) { return this.cached.surfaceIntegralElements; }
  var triangles = [];
  var firstVertex = this.vertices.first.data;
  var plane = this.plane;
  this.vertices.each(function(node, i) {
    if (i &#x3c; 2) { return; }
    var points = [firstVertex, node.prev.data, node.data];
    // If the vertices lie on a straigh line, give the polygon&#x27;s own plane. If the
    // element has no area, it doesn&#x27;t matter which way its normal faces.
    triangles.push(Polygon.create(points, Plane.fromPoints(points) || plane));
  });
  return this.setCache(&#x27;surfaceIntegralElements&#x27;, triangles);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    A = A.data.elements; B = B.data.elements; C = C.data.elements;
    return 0.5 * Vector.create([
      (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),
      (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),
      (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])
    ]).modulus();
  } else {
    var trigs = this.<span class="apidocCodeKeywordSpan">trianglesForSurfaceIntegral</span>(), area = 0;
    var i = trigs.length;
    while (i--) {
      area += trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
    }
    return area;
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.triangulateByEarClipping" id="apidoc.element.sylvester.polygon.prototype.triangulateByEarClipping">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>triangulateByEarClipping
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">triangulateByEarClipping = function () {
  var poly = this.dup(), triangles = [], success, convexNode, mainNode, trig;
  while (!poly.isTriangle()) {
    success = false;
    while (!success) {
      success = true;
      // Ear tips must be convex vertices - let&#x27;s pick one at random
      convexNode = poly.convexVertices.randomNode();
      mainNode = poly.vertices.withData(convexNode.data);
      // For convex vertices, this order will always be anticlockwise
      trig = Polygon.create([mainNode.data, mainNode.next.data, mainNode.prev.data], this.plane);
      // Now test whether any reflex vertices lie within the ear
      poly.reflexVertices.each(function(node) {
        // Don&#x27;t test points belonging to this triangle. node won&#x27;t be
        // equal to convexNode as node is reflex and vertex is convex.
        if (node.data != mainNode.prev.data &#x26;&#x26; node.data != mainNode.next.data) {
          if (trig.contains(node.data) || trig.hasEdgeContaining(node.data)) { success = false; }
        }
      });
    }
    triangles.push(trig);
    poly.removeVertex(mainNode.data);
  }
  // Need to do this to renumber the remaining vertices
  triangles.push(Polygon.create(poly.vertices, this.plane));
  return triangles;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return success;
},

// Returns an array of 3-vertex polygons that the original has been split into
// Stores the first calculation for faster retrieval later on
toTriangles: function() {
  if (this.cached.triangles !== null) { return this.cached.triangles; }
  return this.setCache(&#x27;triangles&#x27;, this.<span class="apidocCodeKeywordSpan">triangulateByEarClipping</span>());
},

// Implementation of ear clipping algorithm
// Found in &#x27;Triangulation by ear clipping&#x27;, by David Eberly
// at http://www.geometrictools.com
// This will not deal with overlapping sections - contruct your polygons sensibly
triangulateByEarClipping: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.updateTrianglePlanes" id="apidoc.element.sylvester.polygon.prototype.updateTrianglePlanes">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>updateTrianglePlanes
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateTrianglePlanes = function (fn) {
  var i;
  if (this.cached.triangles !== null) {
    i = this.cached.triangles.length;
    while (i--) {
      this.cached.triangles[i].plane = fn(this.cached.triangles[i].plane);
    }
  }
  if (this.cached.surfaceIntegralElements !== null) {
    i = this.cached.surfaceIntegralElements.length;
    while (i--) {
      this.cached.surfaceIntegralElements[i].plane = fn(this.cached.surfaceIntegralElements[i].plane);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
translate: function(vector) {
  var P = vector.elements || vector;
  this.vertices.each(function(node) {
    var E = node.data.elements;
    node.data.setElements([E[0] + P[0], E[1] + P[1], E[2] + (P[2] || 0)]);
  });
  this.plane = this.plane.translate(vector);
  this.<span class="apidocCodeKeywordSpan">updateTrianglePlanes</span>(function(plane) { return plane.translate(vector); });
  return this;
},

// Rotates the polygon about the given line and returns the polygon.
rotate: function(t, line) {
  var R = Matrix.Rotation(t, line.direction);
  this.vertices.each(function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sylvester.polygon.prototype.v" id="apidoc.element.sylvester.polygon.prototype.v">
        function <span class="apidocSignatureSpan">sylvester.polygon.prototype.</span>v
        <span class="apidocSignatureSpan">(i)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">v = function (i) {
  return this.vertices.at(i - 1).data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
},

// Returns the centroid of the polygon. Requires division into
// triangles - use with caution
centroid: function() {
  if (this.isTriangle()) {
    var A = this.<span class="apidocCodeKeywordSpan">v</span>(1).elements, B = this.v(2).elements, C = this.v(3).elements;
    return Vector.create([(A[0] + B[0] + C[0])/3, (A[1] + B[1] + C[1])/3, (A[2] + B[2] + C[2])/3]);
  } else {
    var A, M = 0, V = Vector.Zero(3), P, C, trigs = this.trianglesForSurfaceIntegral();
    var i = trigs.length;
    while (i--) {
      A = trigs[i].area() * trigs[i].plane.normal.dot(this.plane.normal);
      M += A;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
